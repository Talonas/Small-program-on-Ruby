<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>/Users/talonas/.gem/ruby/1.8/gems/rake-0.8.7/lib/rake.rb - C0 code coverage information</title>
    <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
    <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
    <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
    <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
    </head>
  <body><h3>C0 code coverage information</h3>
    <p>Generated on Sun Nov 08 18:15:39 +0200 2009 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
      </p>
    <hr/>
    <pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
<table class='report'><thead><tr><td class='heading'>Name</td>
      <td class='heading'>Total lines</td>
      <td class='heading'>Lines of code</td>
      <td class='heading'>Total coverage</td>
      <td class='heading'>Code coverage</td>
      </tr>
    </thead>
  <tbody><tr class='light'><td><a href='-Users-talonas-_gem-ruby-1_8-gems-rake-0_8_7-lib-rake_rb.html'>/Users/talonas/.gem/ruby/1.8/gems/rake-0.8.7/lib/rake.rb</a>
        </td>
      <td class='lines_total'><tt>2506</tt>
        </td>
      <td class='lines_code'><tt>1587</tt>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_total'>56.6%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='57'/>
                  <td class='uncovered' width='43'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_code'>32.3%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='32'/>
                  <td class='uncovered' width='68'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>
<pre><span class="inferred1"><a name="line1"></a>   1 #!/usr/bin/env ruby
</span><span class="inferred0"><a name="line2"></a>   2 
</span><span class="inferred1"><a name="line3"></a>   3 #--
</span><span class="inferred0"><a name="line4"></a>   4 
</span><span class="inferred1"><a name="line5"></a>   5 # Copyright 2003, 2004, 2005, 2006, 2007, 2008 by Jim Weirich (jim@weirichhouse.org)
</span><span class="inferred0"><a name="line6"></a>   6 #
</span><span class="inferred1"><a name="line7"></a>   7 # Permission is hereby granted, free of charge, to any person obtaining a copy
</span><span class="inferred0"><a name="line8"></a>   8 # of this software and associated documentation files (the &quot;Software&quot;), to
</span><span class="inferred1"><a name="line9"></a>   9 # deal in the Software without restriction, including without limitation the
</span><span class="inferred0"><a name="line10"></a>  10 # rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
</span><span class="inferred1"><a name="line11"></a>  11 # sell copies of the Software, and to permit persons to whom the Software is
</span><span class="inferred0"><a name="line12"></a>  12 # furnished to do so, subject to the following conditions:
</span><span class="inferred1"><a name="line13"></a>  13 #
</span><span class="inferred0"><a name="line14"></a>  14 # The above copyright notice and this permission notice shall be included in
</span><span class="inferred1"><a name="line15"></a>  15 # all copies or substantial portions of the Software.
</span><span class="inferred0"><a name="line16"></a>  16 #
</span><span class="inferred1"><a name="line17"></a>  17 # THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
</span><span class="inferred0"><a name="line18"></a>  18 # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
</span><span class="inferred1"><a name="line19"></a>  19 # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
</span><span class="inferred0"><a name="line20"></a>  20 # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
</span><span class="inferred1"><a name="line21"></a>  21 # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
</span><span class="inferred0"><a name="line22"></a>  22 # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
</span><span class="inferred1"><a name="line23"></a>  23 # IN THE SOFTWARE.
</span><span class="inferred0"><a name="line24"></a>  24 #++
</span><span class="inferred1"><a name="line25"></a>  25 #
</span><span class="inferred0"><a name="line26"></a>  26 # = Rake -- Ruby Make
</span><span class="inferred1"><a name="line27"></a>  27 #
</span><span class="inferred0"><a name="line28"></a>  28 # This is the main file for the Rake application.  Normally it is referenced
</span><span class="inferred1"><a name="line29"></a>  29 # as a library via a require statement, but it can be distributed
</span><span class="inferred0"><a name="line30"></a>  30 # independently as an application.
</span><span class="inferred1"><a name="line31"></a>  31 
</span><span class="marked0"><a name="line32"></a>  32 RAKEVERSION = '0.8.7'
</span><span class="inferred1"><a name="line33"></a>  33 
</span><span class="marked0"><a name="line34"></a>  34 require 'rbconfig'
</span><span class="marked1"><a name="line35"></a>  35 require 'fileutils'
</span><span class="marked0"><a name="line36"></a>  36 require 'singleton'
</span><span class="marked1"><a name="line37"></a>  37 require 'monitor'
</span><span class="marked0"><a name="line38"></a>  38 require 'optparse'
</span><span class="marked1"><a name="line39"></a>  39 require 'ostruct'
</span><span class="inferred0"><a name="line40"></a>  40 
</span><span class="marked1"><a name="line41"></a>  41 require 'rake/win32'
</span><span class="inferred0"><a name="line42"></a>  42 
</span><span class="marked1"><a name="line43"></a>  43 $trace = false
</span><span class="inferred0"><a name="line44"></a>  44 
</span><span class="inferred1"><a name="line45"></a>  45 ######################################################################
</span><span class="inferred0"><a name="line46"></a>  46 # Rake extensions to Module.
</span><span class="inferred1"><a name="line47"></a>  47 #
</span><span class="marked0"><a name="line48"></a>  48 class Module
</span><span class="inferred1"><a name="line49"></a>  49   # Check for an existing method in the current class before extending.  IF
</span><span class="inferred0"><a name="line50"></a>  50   # the method already exists, then a warning is printed and the extension is
</span><span class="inferred1"><a name="line51"></a>  51   # not added.  Otherwise the block is yielded and any definitions in the
</span><span class="inferred0"><a name="line52"></a>  52   # block will take effect.
</span><span class="inferred1"><a name="line53"></a>  53   #
</span><span class="inferred0"><a name="line54"></a>  54   # Usage:
</span><span class="inferred1"><a name="line55"></a>  55   #
</span><span class="inferred0"><a name="line56"></a>  56   #   class String
</span><span class="inferred1"><a name="line57"></a>  57   #     rake_extension(&quot;xyz&quot;) do
</span><span class="inferred0"><a name="line58"></a>  58   #       def xyz
</span><span class="inferred1"><a name="line59"></a>  59   #         ...
</span><span class="inferred0"><a name="line60"></a>  60   #       end
</span><span class="inferred1"><a name="line61"></a>  61   #     end
</span><span class="inferred0"><a name="line62"></a>  62   #   end
</span><span class="inferred1"><a name="line63"></a>  63   #
</span><span class="marked0"><a name="line64"></a>  64   def rake_extension(method)
</span><span class="marked1"><a name="line65"></a>  65     if method_defined?(method)
</span><span class="uncovered0"><a name="line66"></a>  66       $stderr.puts &quot;WARNING: Possible conflict with Rake extension: #{self}##{method} already exists&quot;
</span><span class="inferred1"><a name="line67"></a>  67     else
</span><span class="marked0"><a name="line68"></a>  68       yield
</span><span class="inferred1"><a name="line69"></a>  69     end
</span><span class="marked0"><a name="line70"></a>  70   end
</span><span class="inferred1"><a name="line71"></a>  71 end # module Module
</span><span class="inferred0"><a name="line72"></a>  72 
</span><span class="inferred1"><a name="line73"></a>  73 
</span><span class="inferred0"><a name="line74"></a>  74 ######################################################################
</span><span class="inferred1"><a name="line75"></a>  75 # User defined methods to be added to String.
</span><span class="inferred0"><a name="line76"></a>  76 #
</span><span class="marked1"><a name="line77"></a>  77 class String
</span><span class="marked0"><a name="line78"></a>  78   rake_extension(&quot;ext&quot;) do
</span><span class="inferred1"><a name="line79"></a>  79     # Replace the file extension with +newext+.  If there is no extension on
</span><span class="inferred0"><a name="line80"></a>  80     # the string, append the new extension to the end.  If the new extension
</span><span class="inferred1"><a name="line81"></a>  81     # is not given, or is the empty string, remove any existing extension.
</span><span class="inferred0"><a name="line82"></a>  82     #
</span><span class="inferred1"><a name="line83"></a>  83     # +ext+ is a user added method for the String class.
</span><span class="marked0"><a name="line84"></a>  84     def ext(newext='')
</span><span class="uncovered1"><a name="line85"></a>  85       return self.dup if ['.', '..'].include? self
</span><span class="uncovered0"><a name="line86"></a>  86       if newext != ''
</span><span class="uncovered1"><a name="line87"></a>  87         newext = (newext =~ /^\./) ? newext : (&quot;.&quot; + newext)
</span><span class="uncovered0"><a name="line88"></a>  88       end
</span><span class="uncovered1"><a name="line89"></a>  89       self.chomp(File.extname(self)) &lt;&lt; newext
</span><span class="uncovered0"><a name="line90"></a>  90     end
</span><span class="uncovered1"><a name="line91"></a>  91   end
</span><span class="inferred0"><a name="line92"></a>  92 
</span><span class="marked1"><a name="line93"></a>  93   rake_extension(&quot;pathmap&quot;) do
</span><span class="inferred0"><a name="line94"></a>  94     # Explode a path into individual components.  Used by +pathmap+.
</span><span class="marked1"><a name="line95"></a>  95     def pathmap_explode
</span><span class="uncovered0"><a name="line96"></a>  96       head, tail = File.split(self)
</span><span class="uncovered1"><a name="line97"></a>  97       return [self] if head == self
</span><span class="uncovered0"><a name="line98"></a>  98       return [tail] if head == '.' || tail == '/'
</span><span class="uncovered1"><a name="line99"></a>  99       return [head, tail] if head == '/'
</span><span class="uncovered0"><a name="line100"></a> 100       return head.pathmap_explode + [tail]
</span><span class="uncovered1"><a name="line101"></a> 101     end
</span><span class="marked0"><a name="line102"></a> 102     protected :pathmap_explode
</span><span class="inferred1"><a name="line103"></a> 103 
</span><span class="inferred0"><a name="line104"></a> 104     # Extract a partial path from the path.  Include +n+ directories from the
</span><span class="inferred1"><a name="line105"></a> 105     # front end (left hand side) if +n+ is positive.  Include |+n+|
</span><span class="inferred0"><a name="line106"></a> 106     # directories from the back end (right hand side) if +n+ is negative.
</span><span class="marked1"><a name="line107"></a> 107     def pathmap_partial(n)
</span><span class="uncovered0"><a name="line108"></a> 108       dirs = File.dirname(self).pathmap_explode
</span><span class="uncovered1"><a name="line109"></a> 109       partial_dirs =
</span><span class="uncovered0"><a name="line110"></a> 110         if n &gt; 0
</span><span class="uncovered1"><a name="line111"></a> 111           dirs[0...n]
</span><span class="uncovered0"><a name="line112"></a> 112         elsif n &lt; 0
</span><span class="uncovered1"><a name="line113"></a> 113           dirs.reverse[0...-n].reverse
</span><span class="uncovered0"><a name="line114"></a> 114         else
</span><span class="uncovered1"><a name="line115"></a> 115           &quot;.&quot;
</span><span class="uncovered0"><a name="line116"></a> 116         end
</span><span class="uncovered1"><a name="line117"></a> 117       File.join(partial_dirs)
</span><span class="uncovered0"><a name="line118"></a> 118     end
</span><span class="marked1"><a name="line119"></a> 119     protected :pathmap_partial
</span><span class="inferred0"><a name="line120"></a> 120       
</span><span class="inferred1"><a name="line121"></a> 121     # Preform the pathmap replacement operations on the given path. The
</span><span class="inferred0"><a name="line122"></a> 122     # patterns take the form 'pat1,rep1;pat2,rep2...'.
</span><span class="marked1"><a name="line123"></a> 123     def pathmap_replace(patterns, &amp;block)
</span><span class="uncovered0"><a name="line124"></a> 124       result = self
</span><span class="uncovered1"><a name="line125"></a> 125       patterns.split(';').each do |pair|
</span><span class="uncovered0"><a name="line126"></a> 126         pattern, replacement = pair.split(',')
</span><span class="uncovered1"><a name="line127"></a> 127         pattern = Regexp.new(pattern)
</span><span class="uncovered0"><a name="line128"></a> 128         if replacement == '*' &amp;&amp; block_given?
</span><span class="uncovered1"><a name="line129"></a> 129           result = result.sub(pattern, &amp;block)
</span><span class="uncovered0"><a name="line130"></a> 130         elsif replacement
</span><span class="uncovered1"><a name="line131"></a> 131           result = result.sub(pattern, replacement)
</span><span class="uncovered0"><a name="line132"></a> 132         else
</span><span class="uncovered1"><a name="line133"></a> 133           result = result.sub(pattern, '')
</span><span class="uncovered0"><a name="line134"></a> 134         end
</span><span class="uncovered1"><a name="line135"></a> 135       end
</span><span class="uncovered0"><a name="line136"></a> 136       result
</span><span class="uncovered1"><a name="line137"></a> 137     end
</span><span class="marked0"><a name="line138"></a> 138     protected :pathmap_replace
</span><span class="inferred1"><a name="line139"></a> 139 
</span><span class="inferred0"><a name="line140"></a> 140     # Map the path according to the given specification.  The specification
</span><span class="inferred1"><a name="line141"></a> 141     # controls the details of the mapping.  The following special patterns are
</span><span class="inferred0"><a name="line142"></a> 142     # recognized:
</span><span class="inferred1"><a name="line143"></a> 143     #
</span><span class="inferred0"><a name="line144"></a> 144     # * &lt;b&gt;%p&lt;/b&gt; -- The complete path.
</span><span class="inferred1"><a name="line145"></a> 145     # * &lt;b&gt;%f&lt;/b&gt; -- The base file name of the path, with its file extension,
</span><span class="inferred0"><a name="line146"></a> 146     #   but without any directories.
</span><span class="inferred1"><a name="line147"></a> 147     # * &lt;b&gt;%n&lt;/b&gt; -- The file name of the path without its file extension.
</span><span class="inferred0"><a name="line148"></a> 148     # * &lt;b&gt;%d&lt;/b&gt; -- The directory list of the path.
</span><span class="inferred1"><a name="line149"></a> 149     # * &lt;b&gt;%x&lt;/b&gt; -- The file extension of the path.  An empty string if there
</span><span class="inferred0"><a name="line150"></a> 150     #   is no extension.
</span><span class="inferred1"><a name="line151"></a> 151     # * &lt;b&gt;%X&lt;/b&gt; -- Everything *but* the file extension.
</span><span class="inferred0"><a name="line152"></a> 152     # * &lt;b&gt;%s&lt;/b&gt; -- The alternate file separater if defined, otherwise use
</span><span class="inferred1"><a name="line153"></a> 153     #   the standard file separator.
</span><span class="inferred0"><a name="line154"></a> 154     # * &lt;b&gt;%%&lt;/b&gt; -- A percent sign.
</span><span class="inferred1"><a name="line155"></a> 155     #
</span><span class="inferred0"><a name="line156"></a> 156     # The %d specifier can also have a numeric prefix (e.g. '%2d'). If the
</span><span class="inferred1"><a name="line157"></a> 157     # number is positive, only return (up to) +n+ directories in the path,
</span><span class="inferred0"><a name="line158"></a> 158     # starting from the left hand side.  If +n+ is negative, return (up to)
</span><span class="inferred1"><a name="line159"></a> 159     # |+n+| directories from the right hand side of the path.
</span><span class="inferred0"><a name="line160"></a> 160     #
</span><span class="inferred1"><a name="line161"></a> 161     # Examples:
</span><span class="inferred0"><a name="line162"></a> 162     #
</span><span class="inferred1"><a name="line163"></a> 163     #   'a/b/c/d/file.txt'.pathmap(&quot;%2d&quot;)   =&gt; 'a/b'
</span><span class="inferred0"><a name="line164"></a> 164     #   'a/b/c/d/file.txt'.pathmap(&quot;%-2d&quot;)  =&gt; 'c/d'
</span><span class="inferred1"><a name="line165"></a> 165     #
</span><span class="inferred0"><a name="line166"></a> 166     # Also the %d, %p, %f, %n, %x, and %X operators can take a
</span><span class="inferred1"><a name="line167"></a> 167     # pattern/replacement argument to perform simple string substititions on a
</span><span class="inferred0"><a name="line168"></a> 168     # particular part of the path.  The pattern and replacement are speparated
</span><span class="inferred1"><a name="line169"></a> 169     # by a comma and are enclosed by curly braces.  The replacement spec comes
</span><span class="inferred0"><a name="line170"></a> 170     # after the % character but before the operator letter.  (e.g.
</span><span class="inferred1"><a name="line171"></a> 171     # &quot;%{old,new}d&quot;).  Muliple replacement specs should be separated by
</span><span class="inferred0"><a name="line172"></a> 172     # semi-colons (e.g. &quot;%{old,new;src,bin}d&quot;).
</span><span class="inferred1"><a name="line173"></a> 173     #
</span><span class="inferred0"><a name="line174"></a> 174     # Regular expressions may be used for the pattern, and back refs may be
</span><span class="inferred1"><a name="line175"></a> 175     # used in the replacement text.  Curly braces, commas and semi-colons are
</span><span class="inferred0"><a name="line176"></a> 176     # excluded from both the pattern and replacement text (let's keep parsing
</span><span class="inferred1"><a name="line177"></a> 177     # reasonable).
</span><span class="inferred0"><a name="line178"></a> 178     #
</span><span class="inferred1"><a name="line179"></a> 179     # For example:
</span><span class="inferred0"><a name="line180"></a> 180     #
</span><span class="inferred1"><a name="line181"></a> 181     #    &quot;src/org/onestepback/proj/A.java&quot;.pathmap(&quot;%{^src,bin}X.class&quot;)
</span><span class="inferred0"><a name="line182"></a> 182     #
</span><span class="inferred1"><a name="line183"></a> 183     # returns:
</span><span class="inferred0"><a name="line184"></a> 184     #
</span><span class="inferred1"><a name="line185"></a> 185     #    &quot;bin/org/onestepback/proj/A.class&quot;
</span><span class="inferred0"><a name="line186"></a> 186     #
</span><span class="inferred1"><a name="line187"></a> 187     # If the replacement text is '*', then a block may be provided to perform
</span><span class="inferred0"><a name="line188"></a> 188     # some arbitrary calculation for the replacement.
</span><span class="inferred1"><a name="line189"></a> 189     #
</span><span class="inferred0"><a name="line190"></a> 190     # For example:
</span><span class="inferred1"><a name="line191"></a> 191     #
</span><span class="inferred0"><a name="line192"></a> 192     #   &quot;/path/to/file.TXT&quot;.pathmap(&quot;%X%{.*,*}x&quot;) { |ext|
</span><span class="inferred1"><a name="line193"></a> 193     #      ext.downcase
</span><span class="inferred0"><a name="line194"></a> 194     #   }
</span><span class="inferred1"><a name="line195"></a> 195     #
</span><span class="inferred0"><a name="line196"></a> 196     # Returns:
</span><span class="inferred1"><a name="line197"></a> 197     #
</span><span class="inferred0"><a name="line198"></a> 198     #  &quot;/path/to/file.txt&quot;
</span><span class="inferred1"><a name="line199"></a> 199     #
</span><span class="marked0"><a name="line200"></a> 200     def pathmap(spec=nil, &amp;block)
</span><span class="uncovered1"><a name="line201"></a> 201       return self if spec.nil?
</span><span class="uncovered0"><a name="line202"></a> 202       result = ''
</span><span class="uncovered1"><a name="line203"></a> 203       spec.scan(/%\{[^}]*\}-?\d*[sdpfnxX%]|%-?\d+d|%.|[^%]+/) do |frag|
</span><span class="uncovered0"><a name="line204"></a> 204         case frag
</span><span class="uncovered1"><a name="line205"></a> 205         when '%f'
</span><span class="uncovered0"><a name="line206"></a> 206           result &lt;&lt; File.basename(self)
</span><span class="uncovered1"><a name="line207"></a> 207         when '%n'
</span><span class="uncovered0"><a name="line208"></a> 208           result &lt;&lt; File.basename(self).ext
</span><span class="uncovered1"><a name="line209"></a> 209         when '%d'
</span><span class="uncovered0"><a name="line210"></a> 210           result &lt;&lt; File.dirname(self)
</span><span class="uncovered1"><a name="line211"></a> 211         when '%x'
</span><span class="uncovered0"><a name="line212"></a> 212           result &lt;&lt; File.extname(self)
</span><span class="uncovered1"><a name="line213"></a> 213         when '%X'
</span><span class="uncovered0"><a name="line214"></a> 214           result &lt;&lt; self.ext
</span><span class="uncovered1"><a name="line215"></a> 215         when '%p'
</span><span class="uncovered0"><a name="line216"></a> 216           result &lt;&lt; self
</span><span class="uncovered1"><a name="line217"></a> 217         when '%s'
</span><span class="uncovered0"><a name="line218"></a> 218           result &lt;&lt; (File::ALT_SEPARATOR || File::SEPARATOR)
</span><span class="uncovered1"><a name="line219"></a> 219         when '%-'
</span><span class="uncovered0"><a name="line220"></a> 220           # do nothing
</span><span class="uncovered1"><a name="line221"></a> 221         when '%%'
</span><span class="uncovered0"><a name="line222"></a> 222           result &lt;&lt; &quot;%&quot;
</span><span class="uncovered1"><a name="line223"></a> 223         when /%(-?\d+)d/
</span><span class="uncovered0"><a name="line224"></a> 224           result &lt;&lt; pathmap_partial($1.to_i)
</span><span class="uncovered1"><a name="line225"></a> 225         when /^%\{([^}]*)\}(\d*[dpfnxX])/
</span><span class="uncovered0"><a name="line226"></a> 226           patterns, operator = $1, $2
</span><span class="uncovered1"><a name="line227"></a> 227           result &lt;&lt; pathmap('%' + operator).pathmap_replace(patterns, &amp;block)
</span><span class="uncovered0"><a name="line228"></a> 228         when /^%/
</span><span class="uncovered1"><a name="line229"></a> 229           fail ArgumentError, &quot;Unknown pathmap specifier #{frag} in '#{spec}'&quot;
</span><span class="uncovered0"><a name="line230"></a> 230         else
</span><span class="uncovered1"><a name="line231"></a> 231           result &lt;&lt; frag
</span><span class="uncovered0"><a name="line232"></a> 232         end
</span><span class="uncovered1"><a name="line233"></a> 233       end
</span><span class="uncovered0"><a name="line234"></a> 234       result
</span><span class="uncovered1"><a name="line235"></a> 235     end
</span><span class="uncovered0"><a name="line236"></a> 236   end
</span><span class="uncovered1"><a name="line237"></a> 237 end # class String
</span><span class="inferred0"><a name="line238"></a> 238 
</span><span class="inferred1"><a name="line239"></a> 239 ##############################################################################
</span><span class="marked0"><a name="line240"></a> 240 module Rake
</span><span class="inferred1"><a name="line241"></a> 241 
</span><span class="inferred0"><a name="line242"></a> 242   # Errors -----------------------------------------------------------
</span><span class="inferred1"><a name="line243"></a> 243 
</span><span class="inferred0"><a name="line244"></a> 244   # Error indicating an ill-formed task declaration.
</span><span class="marked1"><a name="line245"></a> 245   class TaskArgumentError &lt; ArgumentError
</span><span class="inferred0"><a name="line246"></a> 246   end
</span><span class="inferred1"><a name="line247"></a> 247 
</span><span class="inferred0"><a name="line248"></a> 248   # Error indicating a recursion overflow error in task selection.
</span><span class="marked1"><a name="line249"></a> 249   class RuleRecursionOverflowError &lt; StandardError
</span><span class="marked0"><a name="line250"></a> 250     def initialize(*args)
</span><span class="uncovered1"><a name="line251"></a> 251       super
</span><span class="uncovered0"><a name="line252"></a> 252       @targets = []
</span><span class="uncovered1"><a name="line253"></a> 253     end
</span><span class="inferred0"><a name="line254"></a> 254 
</span><span class="marked1"><a name="line255"></a> 255     def add_target(target)
</span><span class="uncovered0"><a name="line256"></a> 256       @targets &lt;&lt; target
</span><span class="uncovered1"><a name="line257"></a> 257     end
</span><span class="inferred0"><a name="line258"></a> 258 
</span><span class="marked1"><a name="line259"></a> 259     def message
</span><span class="uncovered0"><a name="line260"></a> 260       super + &quot;: [&quot; + @targets.reverse.join(' =&gt; ') + &quot;]&quot;
</span><span class="uncovered1"><a name="line261"></a> 261     end
</span><span class="uncovered0"><a name="line262"></a> 262   end
</span><span class="inferred1"><a name="line263"></a> 263 
</span><span class="inferred0"><a name="line264"></a> 264   # --------------------------------------------------------------------------
</span><span class="inferred1"><a name="line265"></a> 265   # Rake module singleton methods.
</span><span class="inferred0"><a name="line266"></a> 266   #
</span><span class="marked1"><a name="line267"></a> 267   class &lt;&lt; self
</span><span class="inferred0"><a name="line268"></a> 268     # Current Rake Application
</span><span class="marked1"><a name="line269"></a> 269     def application
</span><span class="marked0"><a name="line270"></a> 270       @application ||= Rake::Application.new
</span><span class="marked1"><a name="line271"></a> 271     end
</span><span class="inferred0"><a name="line272"></a> 272 
</span><span class="inferred1"><a name="line273"></a> 273     # Set the current Rake application object.
</span><span class="marked0"><a name="line274"></a> 274     def application=(app)
</span><span class="uncovered1"><a name="line275"></a> 275       @application = app
</span><span class="uncovered0"><a name="line276"></a> 276     end
</span><span class="inferred1"><a name="line277"></a> 277 
</span><span class="inferred0"><a name="line278"></a> 278     # Return the original directory where the Rake application was started.
</span><span class="marked1"><a name="line279"></a> 279     def original_dir
</span><span class="uncovered0"><a name="line280"></a> 280       application.original_dir
</span><span class="uncovered1"><a name="line281"></a> 281     end
</span><span class="uncovered0"><a name="line282"></a> 282 
</span><span class="uncovered1"><a name="line283"></a> 283   end
</span><span class="inferred0"><a name="line284"></a> 284 
</span><span class="inferred1"><a name="line285"></a> 285   ####################################################################
</span><span class="inferred0"><a name="line286"></a> 286   # Mixin for creating easily cloned objects.
</span><span class="inferred1"><a name="line287"></a> 287   #
</span><span class="marked0"><a name="line288"></a> 288   module Cloneable
</span><span class="inferred1"><a name="line289"></a> 289     # Clone an object by making a new object and setting all the instance
</span><span class="inferred0"><a name="line290"></a> 290     # variables to the same values.
</span><span class="marked1"><a name="line291"></a> 291     def dup
</span><span class="uncovered0"><a name="line292"></a> 292       sibling = self.class.new
</span><span class="uncovered1"><a name="line293"></a> 293       instance_variables.each do |ivar|
</span><span class="uncovered0"><a name="line294"></a> 294         value = self.instance_variable_get(ivar)
</span><span class="uncovered1"><a name="line295"></a> 295         new_value = value.clone rescue value
</span><span class="uncovered0"><a name="line296"></a> 296         sibling.instance_variable_set(ivar, new_value)
</span><span class="uncovered1"><a name="line297"></a> 297       end
</span><span class="uncovered0"><a name="line298"></a> 298       sibling.taint if tainted?
</span><span class="uncovered1"><a name="line299"></a> 299       sibling
</span><span class="uncovered0"><a name="line300"></a> 300     end
</span><span class="inferred1"><a name="line301"></a> 301 
</span><span class="marked0"><a name="line302"></a> 302     def clone
</span><span class="uncovered1"><a name="line303"></a> 303       sibling = dup
</span><span class="uncovered0"><a name="line304"></a> 304       sibling.freeze if frozen?
</span><span class="uncovered1"><a name="line305"></a> 305       sibling
</span><span class="uncovered0"><a name="line306"></a> 306     end
</span><span class="uncovered1"><a name="line307"></a> 307   end
</span><span class="inferred0"><a name="line308"></a> 308 
</span><span class="inferred1"><a name="line309"></a> 309   ####################################################################
</span><span class="inferred0"><a name="line310"></a> 310   # Exit status class for times the system just gives us a nil.
</span><span class="marked1"><a name="line311"></a> 311   class PseudoStatus
</span><span class="marked0"><a name="line312"></a> 312     attr_reader :exitstatus
</span><span class="marked1"><a name="line313"></a> 313     def initialize(code=0)
</span><span class="uncovered0"><a name="line314"></a> 314       @exitstatus = code
</span><span class="uncovered1"><a name="line315"></a> 315     end
</span><span class="marked0"><a name="line316"></a> 316     def to_i
</span><span class="uncovered1"><a name="line317"></a> 317       @exitstatus &lt;&lt; 8
</span><span class="uncovered0"><a name="line318"></a> 318     end
</span><span class="marked1"><a name="line319"></a> 319     def &gt;&gt;(n)
</span><span class="uncovered0"><a name="line320"></a> 320       to_i &gt;&gt; n
</span><span class="uncovered1"><a name="line321"></a> 321     end
</span><span class="marked0"><a name="line322"></a> 322     def stopped?
</span><span class="uncovered1"><a name="line323"></a> 323       false
</span><span class="uncovered0"><a name="line324"></a> 324     end
</span><span class="marked1"><a name="line325"></a> 325     def exited?
</span><span class="uncovered0"><a name="line326"></a> 326       true
</span><span class="uncovered1"><a name="line327"></a> 327     end
</span><span class="uncovered0"><a name="line328"></a> 328   end
</span><span class="inferred1"><a name="line329"></a> 329 
</span><span class="inferred0"><a name="line330"></a> 330   ####################################################################
</span><span class="inferred1"><a name="line331"></a> 331   # TaskAguments manage the arguments passed to a task.
</span><span class="inferred0"><a name="line332"></a> 332   #
</span><span class="marked1"><a name="line333"></a> 333   class TaskArguments
</span><span class="marked0"><a name="line334"></a> 334     include Enumerable
</span><span class="inferred1"><a name="line335"></a> 335 
</span><span class="marked0"><a name="line336"></a> 336     attr_reader :names
</span><span class="inferred1"><a name="line337"></a> 337 
</span><span class="inferred0"><a name="line338"></a> 338     # Create a TaskArgument object with a list of named arguments
</span><span class="inferred1"><a name="line339"></a> 339     # (given by :names) and a set of associated values (given by
</span><span class="inferred0"><a name="line340"></a> 340     # :values).  :parent is the parent argument object.
</span><span class="marked1"><a name="line341"></a> 341     def initialize(names, values, parent=nil)
</span><span class="marked0"><a name="line342"></a> 342       @names = names
</span><span class="marked1"><a name="line343"></a> 343       @parent = parent
</span><span class="marked0"><a name="line344"></a> 344       @hash = {}
</span><span class="marked1"><a name="line345"></a> 345       names.each_with_index { |name, i|
</span><span class="uncovered0"><a name="line346"></a> 346         @hash[name.to_sym] = values[i] unless values[i].nil?
</span><span class="uncovered1"><a name="line347"></a> 347       }
</span><span class="uncovered0"><a name="line348"></a> 348     end
</span><span class="inferred1"><a name="line349"></a> 349 
</span><span class="inferred0"><a name="line350"></a> 350     # Create a new argument scope using the prerequisite argument
</span><span class="inferred1"><a name="line351"></a> 351     # names.
</span><span class="marked0"><a name="line352"></a> 352     def new_scope(names)
</span><span class="uncovered1"><a name="line353"></a> 353       values = names.collect { |n| self[n] }
</span><span class="uncovered0"><a name="line354"></a> 354       self.class.new(names, values, self)
</span><span class="uncovered1"><a name="line355"></a> 355     end
</span><span class="inferred0"><a name="line356"></a> 356 
</span><span class="inferred1"><a name="line357"></a> 357     # Find an argument value by name or index.
</span><span class="marked0"><a name="line358"></a> 358     def [](index)
</span><span class="uncovered1"><a name="line359"></a> 359       lookup(index.to_sym)
</span><span class="uncovered0"><a name="line360"></a> 360     end
</span><span class="inferred1"><a name="line361"></a> 361 
</span><span class="inferred0"><a name="line362"></a> 362     # Specify a hash of default values for task arguments. Use the
</span><span class="inferred1"><a name="line363"></a> 363     # defaults only if there is no specific value for the given
</span><span class="inferred0"><a name="line364"></a> 364     # argument.
</span><span class="marked1"><a name="line365"></a> 365     def with_defaults(defaults)
</span><span class="uncovered0"><a name="line366"></a> 366       @hash = defaults.merge(@hash)
</span><span class="uncovered1"><a name="line367"></a> 367     end
</span><span class="inferred0"><a name="line368"></a> 368 
</span><span class="marked1"><a name="line369"></a> 369     def each(&amp;block)
</span><span class="uncovered0"><a name="line370"></a> 370       @hash.each(&amp;block)
</span><span class="uncovered1"><a name="line371"></a> 371     end
</span><span class="inferred0"><a name="line372"></a> 372 
</span><span class="marked1"><a name="line373"></a> 373     def method_missing(sym, *args, &amp;block)
</span><span class="uncovered0"><a name="line374"></a> 374       lookup(sym.to_sym)
</span><span class="uncovered1"><a name="line375"></a> 375     end
</span><span class="inferred0"><a name="line376"></a> 376 
</span><span class="marked1"><a name="line377"></a> 377     def to_hash
</span><span class="uncovered0"><a name="line378"></a> 378       @hash
</span><span class="uncovered1"><a name="line379"></a> 379     end
</span><span class="inferred0"><a name="line380"></a> 380 
</span><span class="marked1"><a name="line381"></a> 381     def to_s
</span><span class="uncovered0"><a name="line382"></a> 382       @hash.inspect
</span><span class="uncovered1"><a name="line383"></a> 383     end
</span><span class="inferred0"><a name="line384"></a> 384 
</span><span class="marked1"><a name="line385"></a> 385     def inspect
</span><span class="uncovered0"><a name="line386"></a> 386       to_s
</span><span class="uncovered1"><a name="line387"></a> 387     end
</span><span class="inferred0"><a name="line388"></a> 388     
</span><span class="marked1"><a name="line389"></a> 389     protected
</span><span class="inferred0"><a name="line390"></a> 390     
</span><span class="marked1"><a name="line391"></a> 391     def lookup(name)
</span><span class="uncovered0"><a name="line392"></a> 392       if @hash.has_key?(name)
</span><span class="uncovered1"><a name="line393"></a> 393         @hash[name]
</span><span class="uncovered0"><a name="line394"></a> 394       elsif ENV.has_key?(name.to_s)
</span><span class="uncovered1"><a name="line395"></a> 395         ENV[name.to_s]
</span><span class="uncovered0"><a name="line396"></a> 396       elsif ENV.has_key?(name.to_s.upcase)
</span><span class="uncovered1"><a name="line397"></a> 397         ENV[name.to_s.upcase]
</span><span class="uncovered0"><a name="line398"></a> 398       elsif @parent
</span><span class="uncovered1"><a name="line399"></a> 399         @parent.lookup(name)
</span><span class="uncovered0"><a name="line400"></a> 400       end
</span><span class="uncovered1"><a name="line401"></a> 401     end
</span><span class="uncovered0"><a name="line402"></a> 402   end
</span><span class="inferred1"><a name="line403"></a> 403 
</span><span class="marked0"><a name="line404"></a> 404   EMPTY_TASK_ARGS = TaskArguments.new([], [])
</span><span class="inferred1"><a name="line405"></a> 405 
</span><span class="inferred0"><a name="line406"></a> 406   ####################################################################
</span><span class="inferred1"><a name="line407"></a> 407   # InvocationChain tracks the chain of task invocations to detect
</span><span class="inferred0"><a name="line408"></a> 408   # circular dependencies.
</span><span class="marked1"><a name="line409"></a> 409   class InvocationChain
</span><span class="marked0"><a name="line410"></a> 410     def initialize(value, tail)
</span><span class="uncovered1"><a name="line411"></a> 411       @value = value
</span><span class="uncovered0"><a name="line412"></a> 412       @tail = tail
</span><span class="uncovered1"><a name="line413"></a> 413     end
</span><span class="inferred0"><a name="line414"></a> 414 
</span><span class="marked1"><a name="line415"></a> 415     def member?(obj)
</span><span class="uncovered0"><a name="line416"></a> 416       @value == obj || @tail.member?(obj)
</span><span class="uncovered1"><a name="line417"></a> 417     end
</span><span class="inferred0"><a name="line418"></a> 418 
</span><span class="marked1"><a name="line419"></a> 419     def append(value)
</span><span class="uncovered0"><a name="line420"></a> 420       if member?(value)
</span><span class="uncovered1"><a name="line421"></a> 421         fail RuntimeError, &quot;Circular dependency detected: #{to_s} =&gt; #{value}&quot;
</span><span class="uncovered0"><a name="line422"></a> 422       end
</span><span class="uncovered1"><a name="line423"></a> 423       self.class.new(value, self)
</span><span class="uncovered0"><a name="line424"></a> 424     end
</span><span class="inferred1"><a name="line425"></a> 425 
</span><span class="marked0"><a name="line426"></a> 426     def to_s
</span><span class="uncovered1"><a name="line427"></a> 427       &quot;#{prefix}#{@value}&quot;
</span><span class="uncovered0"><a name="line428"></a> 428     end
</span><span class="inferred1"><a name="line429"></a> 429 
</span><span class="marked0"><a name="line430"></a> 430     def self.append(value, chain)
</span><span class="uncovered1"><a name="line431"></a> 431       chain.append(value)
</span><span class="uncovered0"><a name="line432"></a> 432     end
</span><span class="inferred1"><a name="line433"></a> 433 
</span><span class="marked0"><a name="line434"></a> 434     private
</span><span class="inferred1"><a name="line435"></a> 435 
</span><span class="marked0"><a name="line436"></a> 436     def prefix
</span><span class="uncovered1"><a name="line437"></a> 437       &quot;#{@tail.to_s} =&gt; &quot;
</span><span class="uncovered0"><a name="line438"></a> 438     end
</span><span class="inferred1"><a name="line439"></a> 439 
</span><span class="marked0"><a name="line440"></a> 440     class EmptyInvocationChain
</span><span class="marked1"><a name="line441"></a> 441       def member?(obj)
</span><span class="uncovered0"><a name="line442"></a> 442         false
</span><span class="uncovered1"><a name="line443"></a> 443       end
</span><span class="marked0"><a name="line444"></a> 444       def append(value)
</span><span class="uncovered1"><a name="line445"></a> 445         InvocationChain.new(value, self)
</span><span class="uncovered0"><a name="line446"></a> 446       end
</span><span class="marked1"><a name="line447"></a> 447       def to_s
</span><span class="uncovered0"><a name="line448"></a> 448         &quot;TOP&quot;
</span><span class="uncovered1"><a name="line449"></a> 449       end
</span><span class="uncovered0"><a name="line450"></a> 450     end
</span><span class="inferred1"><a name="line451"></a> 451 
</span><span class="marked0"><a name="line452"></a> 452     EMPTY = EmptyInvocationChain.new
</span><span class="inferred1"><a name="line453"></a> 453 
</span><span class="inferred0"><a name="line454"></a> 454   end # class InvocationChain
</span><span class="inferred1"><a name="line455"></a> 455 
</span><span class="inferred0"><a name="line456"></a> 456 end # module Rake
</span><span class="inferred1"><a name="line457"></a> 457 
</span><span class="marked0"><a name="line458"></a> 458 module Rake
</span><span class="inferred1"><a name="line459"></a> 459 
</span><span class="inferred0"><a name="line460"></a> 460   ###########################################################################
</span><span class="inferred1"><a name="line461"></a> 461   # A Task is the basic unit of work in a Rakefile.  Tasks have associated
</span><span class="inferred0"><a name="line462"></a> 462   # actions (possibly more than one) and a list of prerequisites.  When
</span><span class="inferred1"><a name="line463"></a> 463   # invoked, a task will first ensure that all of its prerequisites have an
</span><span class="inferred0"><a name="line464"></a> 464   # opportunity to run and then it will execute its own actions.
</span><span class="inferred1"><a name="line465"></a> 465   #
</span><span class="inferred0"><a name="line466"></a> 466   # Tasks are not usually created directly using the new method, but rather
</span><span class="inferred1"><a name="line467"></a> 467   # use the +file+ and +task+ convenience methods.
</span><span class="inferred0"><a name="line468"></a> 468   #
</span><span class="marked1"><a name="line469"></a> 469   class Task
</span><span class="inferred0"><a name="line470"></a> 470     # List of prerequisites for a task.
</span><span class="marked1"><a name="line471"></a> 471     attr_reader :prerequisites
</span><span class="inferred0"><a name="line472"></a> 472 
</span><span class="inferred1"><a name="line473"></a> 473     # List of actions attached to a task.
</span><span class="marked0"><a name="line474"></a> 474     attr_reader :actions
</span><span class="inferred1"><a name="line475"></a> 475 
</span><span class="inferred0"><a name="line476"></a> 476     # Application owning this task.
</span><span class="marked1"><a name="line477"></a> 477     attr_accessor :application
</span><span class="inferred0"><a name="line478"></a> 478 
</span><span class="inferred1"><a name="line479"></a> 479     # Comment for this task.  Restricted to a single line of no more than 50
</span><span class="inferred0"><a name="line480"></a> 480     # characters.
</span><span class="marked1"><a name="line481"></a> 481     attr_reader :comment
</span><span class="inferred0"><a name="line482"></a> 482 
</span><span class="inferred1"><a name="line483"></a> 483     # Full text of the (possibly multi-line) comment.
</span><span class="marked0"><a name="line484"></a> 484     attr_reader :full_comment
</span><span class="inferred1"><a name="line485"></a> 485 
</span><span class="inferred0"><a name="line486"></a> 486     # Array of nested namespaces names used for task lookup by this task.
</span><span class="marked1"><a name="line487"></a> 487     attr_reader :scope
</span><span class="inferred0"><a name="line488"></a> 488 
</span><span class="inferred1"><a name="line489"></a> 489     # Return task name
</span><span class="marked0"><a name="line490"></a> 490     def to_s
</span><span class="uncovered1"><a name="line491"></a> 491       name
</span><span class="uncovered0"><a name="line492"></a> 492     end
</span><span class="inferred1"><a name="line493"></a> 493 
</span><span class="marked0"><a name="line494"></a> 494     def inspect
</span><span class="uncovered1"><a name="line495"></a> 495       &quot;&lt;#{self.class} #{name} =&gt; [#{prerequisites.join(', ')}]&gt;&quot;
</span><span class="uncovered0"><a name="line496"></a> 496     end
</span><span class="inferred1"><a name="line497"></a> 497 
</span><span class="inferred0"><a name="line498"></a> 498     # List of sources for task.
</span><span class="marked1"><a name="line499"></a> 499     attr_writer :sources
</span><span class="marked0"><a name="line500"></a> 500     def sources
</span><span class="uncovered1"><a name="line501"></a> 501       @sources ||= []
</span><span class="uncovered0"><a name="line502"></a> 502     end
</span><span class="inferred1"><a name="line503"></a> 503 
</span><span class="inferred0"><a name="line504"></a> 504     # First source from a rule (nil if no sources)
</span><span class="marked1"><a name="line505"></a> 505     def source
</span><span class="uncovered0"><a name="line506"></a> 506       @sources.first if defined?(@sources)
</span><span class="uncovered1"><a name="line507"></a> 507     end
</span><span class="inferred0"><a name="line508"></a> 508 
</span><span class="inferred1"><a name="line509"></a> 509     # Create a task named +task_name+ with no actions or prerequisites. Use
</span><span class="inferred0"><a name="line510"></a> 510     # +enhance+ to add actions and prerequisites.
</span><span class="marked1"><a name="line511"></a> 511     def initialize(task_name, app)
</span><span class="marked0"><a name="line512"></a> 512       @name = task_name.to_s
</span><span class="marked1"><a name="line513"></a> 513       @prerequisites = []
</span><span class="marked0"><a name="line514"></a> 514       @actions = []
</span><span class="marked1"><a name="line515"></a> 515       @already_invoked = false
</span><span class="marked0"><a name="line516"></a> 516       @full_comment = nil
</span><span class="marked1"><a name="line517"></a> 517       @comment = nil
</span><span class="marked0"><a name="line518"></a> 518       @lock = Monitor.new
</span><span class="marked1"><a name="line519"></a> 519       @application = app
</span><span class="marked0"><a name="line520"></a> 520       @scope = app.current_scope
</span><span class="marked1"><a name="line521"></a> 521       @arg_names = nil
</span><span class="inferred0"><a name="line522"></a> 522     end
</span><span class="inferred1"><a name="line523"></a> 523 
</span><span class="inferred0"><a name="line524"></a> 524     # Enhance a task with prerequisites or actions.  Returns self.
</span><span class="marked1"><a name="line525"></a> 525     def enhance(deps=nil, &amp;block)
</span><span class="marked0"><a name="line526"></a> 526       @prerequisites |= deps if deps
</span><span class="marked1"><a name="line527"></a> 527       @actions &lt;&lt; block if block_given?
</span><span class="marked0"><a name="line528"></a> 528       self
</span><span class="inferred1"><a name="line529"></a> 529     end
</span><span class="inferred0"><a name="line530"></a> 530 
</span><span class="inferred1"><a name="line531"></a> 531     # Name of the task, including any namespace qualifiers.
</span><span class="marked0"><a name="line532"></a> 532     def name
</span><span class="uncovered1"><a name="line533"></a> 533       @name.to_s
</span><span class="uncovered0"><a name="line534"></a> 534     end
</span><span class="inferred1"><a name="line535"></a> 535 
</span><span class="inferred0"><a name="line536"></a> 536     # Name of task with argument list description.
</span><span class="marked1"><a name="line537"></a> 537     def name_with_args # :nodoc:
</span><span class="uncovered0"><a name="line538"></a> 538       if arg_description
</span><span class="uncovered1"><a name="line539"></a> 539         &quot;#{name}#{arg_description}&quot;
</span><span class="uncovered0"><a name="line540"></a> 540       else
</span><span class="uncovered1"><a name="line541"></a> 541         name
</span><span class="uncovered0"><a name="line542"></a> 542       end
</span><span class="uncovered1"><a name="line543"></a> 543     end
</span><span class="inferred0"><a name="line544"></a> 544 
</span><span class="inferred1"><a name="line545"></a> 545     # Argument description (nil if none).
</span><span class="marked0"><a name="line546"></a> 546     def arg_description # :nodoc:
</span><span class="uncovered1"><a name="line547"></a> 547       @arg_names ? &quot;[#{(arg_names || []).join(',')}]&quot; : nil
</span><span class="uncovered0"><a name="line548"></a> 548     end
</span><span class="inferred1"><a name="line549"></a> 549 
</span><span class="inferred0"><a name="line550"></a> 550     # Name of arguments for this task.
</span><span class="marked1"><a name="line551"></a> 551     def arg_names
</span><span class="uncovered0"><a name="line552"></a> 552       @arg_names || []
</span><span class="uncovered1"><a name="line553"></a> 553     end
</span><span class="inferred0"><a name="line554"></a> 554 
</span><span class="inferred1"><a name="line555"></a> 555     # Reenable the task, allowing its tasks to be executed if the task
</span><span class="inferred0"><a name="line556"></a> 556     # is invoked again.
</span><span class="marked1"><a name="line557"></a> 557     def reenable
</span><span class="uncovered0"><a name="line558"></a> 558       @already_invoked = false
</span><span class="uncovered1"><a name="line559"></a> 559     end
</span><span class="inferred0"><a name="line560"></a> 560 
</span><span class="inferred1"><a name="line561"></a> 561     # Clear the existing prerequisites and actions of a rake task.
</span><span class="marked0"><a name="line562"></a> 562     def clear
</span><span class="uncovered1"><a name="line563"></a> 563       clear_prerequisites
</span><span class="uncovered0"><a name="line564"></a> 564       clear_actions
</span><span class="uncovered1"><a name="line565"></a> 565       self
</span><span class="uncovered0"><a name="line566"></a> 566     end
</span><span class="inferred1"><a name="line567"></a> 567 
</span><span class="inferred0"><a name="line568"></a> 568     # Clear the existing prerequisites of a rake task.
</span><span class="marked1"><a name="line569"></a> 569     def clear_prerequisites
</span><span class="uncovered0"><a name="line570"></a> 570       prerequisites.clear
</span><span class="uncovered1"><a name="line571"></a> 571       self
</span><span class="uncovered0"><a name="line572"></a> 572     end
</span><span class="inferred1"><a name="line573"></a> 573 
</span><span class="inferred0"><a name="line574"></a> 574     # Clear the existing actions on a rake task.
</span><span class="marked1"><a name="line575"></a> 575     def clear_actions
</span><span class="uncovered0"><a name="line576"></a> 576       actions.clear
</span><span class="uncovered1"><a name="line577"></a> 577       self
</span><span class="uncovered0"><a name="line578"></a> 578     end
</span><span class="inferred1"><a name="line579"></a> 579 
</span><span class="inferred0"><a name="line580"></a> 580     # Invoke the task if it is needed.  Prerequites are invoked first.
</span><span class="marked1"><a name="line581"></a> 581     def invoke(*args)
</span><span class="uncovered0"><a name="line582"></a> 582       task_args = TaskArguments.new(arg_names, args)
</span><span class="uncovered1"><a name="line583"></a> 583       invoke_with_call_chain(task_args, InvocationChain::EMPTY)
</span><span class="uncovered0"><a name="line584"></a> 584     end
</span><span class="inferred1"><a name="line585"></a> 585 
</span><span class="inferred0"><a name="line586"></a> 586     # Same as invoke, but explicitly pass a call chain to detect
</span><span class="inferred1"><a name="line587"></a> 587     # circular dependencies.
</span><span class="marked0"><a name="line588"></a> 588     def invoke_with_call_chain(task_args, invocation_chain) # :nodoc:
</span><span class="uncovered1"><a name="line589"></a> 589       new_chain = InvocationChain.append(self, invocation_chain)
</span><span class="uncovered0"><a name="line590"></a> 590       @lock.synchronize do
</span><span class="uncovered1"><a name="line591"></a> 591         if application.options.trace
</span><span class="uncovered0"><a name="line592"></a> 592           puts &quot;** Invoke #{name} #{format_trace_flags}&quot;
</span><span class="uncovered1"><a name="line593"></a> 593         end
</span><span class="uncovered0"><a name="line594"></a> 594         return if @already_invoked
</span><span class="uncovered1"><a name="line595"></a> 595         @already_invoked = true
</span><span class="uncovered0"><a name="line596"></a> 596         invoke_prerequisites(task_args, new_chain)
</span><span class="uncovered1"><a name="line597"></a> 597         execute(task_args) if needed?
</span><span class="uncovered0"><a name="line598"></a> 598       end
</span><span class="uncovered1"><a name="line599"></a> 599     end
</span><span class="marked0"><a name="line600"></a> 600     protected :invoke_with_call_chain
</span><span class="inferred1"><a name="line601"></a> 601 
</span><span class="inferred0"><a name="line602"></a> 602     # Invoke all the prerequisites of a task.
</span><span class="marked1"><a name="line603"></a> 603     def invoke_prerequisites(task_args, invocation_chain) # :nodoc:
</span><span class="uncovered0"><a name="line604"></a> 604       @prerequisites.each { |n|
</span><span class="uncovered1"><a name="line605"></a> 605         prereq = application[n, @scope]
</span><span class="uncovered0"><a name="line606"></a> 606         prereq_args = task_args.new_scope(prereq.arg_names)
</span><span class="uncovered1"><a name="line607"></a> 607         prereq.invoke_with_call_chain(prereq_args, invocation_chain)
</span><span class="uncovered0"><a name="line608"></a> 608       }
</span><span class="uncovered1"><a name="line609"></a> 609     end
</span><span class="inferred0"><a name="line610"></a> 610 
</span><span class="inferred1"><a name="line611"></a> 611     # Format the trace flags for display.
</span><span class="marked0"><a name="line612"></a> 612     def format_trace_flags
</span><span class="uncovered1"><a name="line613"></a> 613       flags = []
</span><span class="uncovered0"><a name="line614"></a> 614       flags &lt;&lt; &quot;first_time&quot; unless @already_invoked
</span><span class="uncovered1"><a name="line615"></a> 615       flags &lt;&lt; &quot;not_needed&quot; unless needed?
</span><span class="uncovered0"><a name="line616"></a> 616       flags.empty? ? &quot;&quot; : &quot;(&quot; + flags.join(&quot;, &quot;) + &quot;)&quot;
</span><span class="uncovered1"><a name="line617"></a> 617     end
</span><span class="marked0"><a name="line618"></a> 618     private :format_trace_flags
</span><span class="inferred1"><a name="line619"></a> 619 
</span><span class="inferred0"><a name="line620"></a> 620     # Execute the actions associated with this task.
</span><span class="marked1"><a name="line621"></a> 621     def execute(args=nil)
</span><span class="uncovered0"><a name="line622"></a> 622       args ||= EMPTY_TASK_ARGS
</span><span class="uncovered1"><a name="line623"></a> 623       if application.options.dryrun
</span><span class="uncovered0"><a name="line624"></a> 624         puts &quot;** Execute (dry run) #{name}&quot;
</span><span class="uncovered1"><a name="line625"></a> 625         return
</span><span class="uncovered0"><a name="line626"></a> 626       end
</span><span class="uncovered1"><a name="line627"></a> 627       if application.options.trace
</span><span class="uncovered0"><a name="line628"></a> 628         puts &quot;** Execute #{name}&quot;
</span><span class="uncovered1"><a name="line629"></a> 629       end
</span><span class="uncovered0"><a name="line630"></a> 630       application.enhance_with_matching_rule(name) if @actions.empty?
</span><span class="uncovered1"><a name="line631"></a> 631       @actions.each do |act|
</span><span class="uncovered0"><a name="line632"></a> 632         case act.arity
</span><span class="uncovered1"><a name="line633"></a> 633         when 1
</span><span class="uncovered0"><a name="line634"></a> 634           act.call(self)
</span><span class="uncovered1"><a name="line635"></a> 635         else
</span><span class="uncovered0"><a name="line636"></a> 636           act.call(self, args)
</span><span class="uncovered1"><a name="line637"></a> 637         end
</span><span class="uncovered0"><a name="line638"></a> 638       end
</span><span class="uncovered1"><a name="line639"></a> 639     end
</span><span class="inferred0"><a name="line640"></a> 640 
</span><span class="inferred1"><a name="line641"></a> 641     # Is this task needed?
</span><span class="marked0"><a name="line642"></a> 642     def needed?
</span><span class="uncovered1"><a name="line643"></a> 643       true
</span><span class="uncovered0"><a name="line644"></a> 644     end
</span><span class="inferred1"><a name="line645"></a> 645 
</span><span class="inferred0"><a name="line646"></a> 646     # Timestamp for this task.  Basic tasks return the current time for their
</span><span class="inferred1"><a name="line647"></a> 647     # time stamp.  Other tasks can be more sophisticated.
</span><span class="marked0"><a name="line648"></a> 648     def timestamp
</span><span class="uncovered1"><a name="line649"></a> 649       @prerequisites.collect { |p| application[p].timestamp }.max || Time.now
</span><span class="uncovered0"><a name="line650"></a> 650     end
</span><span class="inferred1"><a name="line651"></a> 651 
</span><span class="inferred0"><a name="line652"></a> 652     # Add a description to the task.  The description can consist of an option
</span><span class="inferred1"><a name="line653"></a> 653     # argument list (enclosed brackets) and an optional comment.
</span><span class="marked0"><a name="line654"></a> 654     def add_description(description)
</span><span class="marked1"><a name="line655"></a> 655       return if ! description
</span><span class="marked0"><a name="line656"></a> 656       comment = description.strip
</span><span class="marked1"><a name="line657"></a> 657       add_comment(comment) if comment &amp;&amp; ! comment.empty?
</span><span class="inferred0"><a name="line658"></a> 658     end
</span><span class="inferred1"><a name="line659"></a> 659 
</span><span class="inferred0"><a name="line660"></a> 660     # Writing to the comment attribute is the same as adding a description.
</span><span class="marked1"><a name="line661"></a> 661     def comment=(description)
</span><span class="uncovered0"><a name="line662"></a> 662       add_description(description)
</span><span class="uncovered1"><a name="line663"></a> 663     end
</span><span class="inferred0"><a name="line664"></a> 664 
</span><span class="inferred1"><a name="line665"></a> 665     # Add a comment to the task.  If a comment alread exists, separate
</span><span class="inferred0"><a name="line666"></a> 666     # the new comment with &quot; / &quot;.
</span><span class="marked1"><a name="line667"></a> 667     def add_comment(comment)
</span><span class="marked0"><a name="line668"></a> 668       if @full_comment
</span><span class="uncovered1"><a name="line669"></a> 669         @full_comment &lt;&lt; &quot; / &quot;
</span><span class="inferred0"><a name="line670"></a> 670       else
</span><span class="marked1"><a name="line671"></a> 671         @full_comment = ''
</span><span class="inferred0"><a name="line672"></a> 672       end
</span><span class="marked1"><a name="line673"></a> 673       @full_comment &lt;&lt; comment
</span><span class="marked0"><a name="line674"></a> 674       if @full_comment =~ /\A([^.]+?\.)( |$)/
</span><span class="inferred1"><a name="line675"></a> 675         @comment = $1
</span><span class="inferred0"><a name="line676"></a> 676       else
</span><span class="marked1"><a name="line677"></a> 677         @comment = @full_comment
</span><span class="inferred0"><a name="line678"></a> 678       end
</span><span class="inferred1"><a name="line679"></a> 679     end
</span><span class="marked0"><a name="line680"></a> 680     private :add_comment
</span><span class="inferred1"><a name="line681"></a> 681 
</span><span class="inferred0"><a name="line682"></a> 682     # Set the names of the arguments for this task. +args+ should be
</span><span class="inferred1"><a name="line683"></a> 683     # an array of symbols, one for each argument name.
</span><span class="marked0"><a name="line684"></a> 684     def set_arg_names(args)
</span><span class="uncovered1"><a name="line685"></a> 685       @arg_names = args.map { |a| a.to_sym }
</span><span class="uncovered0"><a name="line686"></a> 686     end
</span><span class="inferred1"><a name="line687"></a> 687 
</span><span class="inferred0"><a name="line688"></a> 688     # Return a string describing the internal state of a task.  Useful for
</span><span class="inferred1"><a name="line689"></a> 689     # debugging.
</span><span class="marked0"><a name="line690"></a> 690     def investigation
</span><span class="uncovered1"><a name="line691"></a> 691       result = &quot;------------------------------\n&quot;
</span><span class="uncovered0"><a name="line692"></a> 692       result &lt;&lt; &quot;Investigating #{name}\n&quot;
</span><span class="uncovered1"><a name="line693"></a> 693       result &lt;&lt; &quot;class: #{self.class}\n&quot;
</span><span class="uncovered0"><a name="line694"></a> 694       result &lt;&lt;  &quot;task needed: #{needed?}\n&quot;
</span><span class="uncovered1"><a name="line695"></a> 695       result &lt;&lt;  &quot;timestamp: #{timestamp}\n&quot;
</span><span class="uncovered0"><a name="line696"></a> 696       result &lt;&lt; &quot;pre-requisites: \n&quot;
</span><span class="uncovered1"><a name="line697"></a> 697       prereqs = @prerequisites.collect {|name| application[name]}
</span><span class="uncovered0"><a name="line698"></a> 698       prereqs.sort! {|a,b| a.timestamp &lt;=&gt; b.timestamp}
</span><span class="uncovered1"><a name="line699"></a> 699       prereqs.each do |p|
</span><span class="uncovered0"><a name="line700"></a> 700         result &lt;&lt; &quot;--#{p.name} (#{p.timestamp})\n&quot;
</span><span class="uncovered1"><a name="line701"></a> 701       end
</span><span class="uncovered0"><a name="line702"></a> 702       latest_prereq = @prerequisites.collect{|n| application[n].timestamp}.max
</span><span class="uncovered1"><a name="line703"></a> 703       result &lt;&lt;  &quot;latest-prerequisite time: #{latest_prereq}\n&quot;
</span><span class="uncovered0"><a name="line704"></a> 704       result &lt;&lt; &quot;................................\n\n&quot;
</span><span class="uncovered1"><a name="line705"></a> 705       return result
</span><span class="uncovered0"><a name="line706"></a> 706     end
</span><span class="inferred1"><a name="line707"></a> 707 
</span><span class="inferred0"><a name="line708"></a> 708     # ----------------------------------------------------------------
</span><span class="inferred1"><a name="line709"></a> 709     # Rake Module Methods
</span><span class="inferred0"><a name="line710"></a> 710     #
</span><span class="marked1"><a name="line711"></a> 711     class &lt;&lt; self
</span><span class="inferred0"><a name="line712"></a> 712 
</span><span class="inferred1"><a name="line713"></a> 713       # Clear the task list.  This cause rake to immediately forget all the
</span><span class="inferred0"><a name="line714"></a> 714       # tasks that have been assigned.  (Normally used in the unit tests.)
</span><span class="marked1"><a name="line715"></a> 715       def clear
</span><span class="uncovered0"><a name="line716"></a> 716         Rake.application.clear
</span><span class="uncovered1"><a name="line717"></a> 717       end
</span><span class="inferred0"><a name="line718"></a> 718 
</span><span class="inferred1"><a name="line719"></a> 719       # List of all defined tasks.
</span><span class="marked0"><a name="line720"></a> 720       def tasks
</span><span class="uncovered1"><a name="line721"></a> 721         Rake.application.tasks
</span><span class="uncovered0"><a name="line722"></a> 722       end
</span><span class="inferred1"><a name="line723"></a> 723 
</span><span class="inferred0"><a name="line724"></a> 724       # Return a task with the given name.  If the task is not currently
</span><span class="inferred1"><a name="line725"></a> 725       # known, try to synthesize one from the defined rules.  If no rules are
</span><span class="inferred0"><a name="line726"></a> 726       # found, but an existing file matches the task name, assume it is a file
</span><span class="inferred1"><a name="line727"></a> 727       # task with no dependencies or actions.
</span><span class="marked0"><a name="line728"></a> 728       def [](task_name)
</span><span class="uncovered1"><a name="line729"></a> 729         Rake.application[task_name]
</span><span class="uncovered0"><a name="line730"></a> 730       end
</span><span class="inferred1"><a name="line731"></a> 731 
</span><span class="inferred0"><a name="line732"></a> 732       # TRUE if the task name is already defined.
</span><span class="marked1"><a name="line733"></a> 733       def task_defined?(task_name)
</span><span class="uncovered0"><a name="line734"></a> 734         Rake.application.lookup(task_name) != nil
</span><span class="uncovered1"><a name="line735"></a> 735       end
</span><span class="inferred0"><a name="line736"></a> 736 
</span><span class="inferred1"><a name="line737"></a> 737       # Define a task given +args+ and an option block.  If a rule with the
</span><span class="inferred0"><a name="line738"></a> 738       # given name already exists, the prerequisites and actions are added to
</span><span class="inferred1"><a name="line739"></a> 739       # the existing task.  Returns the defined task.
</span><span class="marked0"><a name="line740"></a> 740       def define_task(*args, &amp;block)
</span><span class="marked1"><a name="line741"></a> 741         Rake.application.define_task(self, *args, &amp;block)
</span><span class="inferred0"><a name="line742"></a> 742       end
</span><span class="inferred1"><a name="line743"></a> 743 
</span><span class="inferred0"><a name="line744"></a> 744       # Define a rule for synthesizing tasks.
</span><span class="marked1"><a name="line745"></a> 745       def create_rule(*args, &amp;block)
</span><span class="uncovered0"><a name="line746"></a> 746         Rake.application.create_rule(*args, &amp;block)
</span><span class="uncovered1"><a name="line747"></a> 747       end
</span><span class="inferred0"><a name="line748"></a> 748 
</span><span class="inferred1"><a name="line749"></a> 749       # Apply the scope to the task name according to the rules for
</span><span class="inferred0"><a name="line750"></a> 750       # this kind of task.  Generic tasks will accept the scope as
</span><span class="inferred1"><a name="line751"></a> 751       # part of the name.
</span><span class="marked0"><a name="line752"></a> 752       def scope_name(scope, task_name)
</span><span class="marked1"><a name="line753"></a> 753         (scope + [task_name]).join(':')
</span><span class="marked0"><a name="line754"></a> 754       end
</span><span class="inferred1"><a name="line755"></a> 755 
</span><span class="inferred0"><a name="line756"></a> 756     end # class &lt;&lt; Rake::Task
</span><span class="inferred1"><a name="line757"></a> 757   end # class Rake::Task
</span><span class="inferred0"><a name="line758"></a> 758 
</span><span class="inferred1"><a name="line759"></a> 759 
</span><span class="inferred0"><a name="line760"></a> 760   ###########################################################################
</span><span class="inferred1"><a name="line761"></a> 761   # A FileTask is a task that includes time based dependencies.  If any of a
</span><span class="inferred0"><a name="line762"></a> 762   # FileTask's prerequisites have a timestamp that is later than the file
</span><span class="inferred1"><a name="line763"></a> 763   # represented by this task, then the file must be rebuilt (using the
</span><span class="inferred0"><a name="line764"></a> 764   # supplied actions).
</span><span class="inferred1"><a name="line765"></a> 765   #
</span><span class="marked0"><a name="line766"></a> 766   class FileTask &lt; Task
</span><span class="inferred1"><a name="line767"></a> 767 
</span><span class="inferred0"><a name="line768"></a> 768     # Is this file task needed?  Yes if it doesn't exist, or if its time stamp
</span><span class="inferred1"><a name="line769"></a> 769     # is out of date.
</span><span class="marked0"><a name="line770"></a> 770     def needed?
</span><span class="uncovered1"><a name="line771"></a> 771       ! File.exist?(name) || out_of_date?(timestamp)
</span><span class="uncovered0"><a name="line772"></a> 772     end
</span><span class="inferred1"><a name="line773"></a> 773 
</span><span class="inferred0"><a name="line774"></a> 774     # Time stamp for file task.
</span><span class="marked1"><a name="line775"></a> 775     def timestamp
</span><span class="uncovered0"><a name="line776"></a> 776       if File.exist?(name)
</span><span class="uncovered1"><a name="line777"></a> 777         File.mtime(name.to_s)
</span><span class="uncovered0"><a name="line778"></a> 778       else
</span><span class="uncovered1"><a name="line779"></a> 779         Rake::EARLY
</span><span class="uncovered0"><a name="line780"></a> 780       end
</span><span class="uncovered1"><a name="line781"></a> 781     end
</span><span class="inferred0"><a name="line782"></a> 782 
</span><span class="marked1"><a name="line783"></a> 783     private
</span><span class="inferred0"><a name="line784"></a> 784 
</span><span class="inferred1"><a name="line785"></a> 785     # Are there any prerequisites with a later time than the given time stamp?
</span><span class="marked0"><a name="line786"></a> 786     def out_of_date?(stamp)
</span><span class="uncovered1"><a name="line787"></a> 787       @prerequisites.any? { |n| application[n].timestamp &gt; stamp}
</span><span class="uncovered0"><a name="line788"></a> 788     end
</span><span class="inferred1"><a name="line789"></a> 789 
</span><span class="inferred0"><a name="line790"></a> 790     # ----------------------------------------------------------------
</span><span class="inferred1"><a name="line791"></a> 791     # Task class methods.
</span><span class="inferred0"><a name="line792"></a> 792     #
</span><span class="marked1"><a name="line793"></a> 793     class &lt;&lt; self
</span><span class="inferred0"><a name="line794"></a> 794       # Apply the scope to the task name according to the rules for this kind
</span><span class="inferred1"><a name="line795"></a> 795       # of task.  File based tasks ignore the scope when creating the name.
</span><span class="marked0"><a name="line796"></a> 796       def scope_name(scope, task_name)
</span><span class="uncovered1"><a name="line797"></a> 797         task_name
</span><span class="uncovered0"><a name="line798"></a> 798       end
</span><span class="uncovered1"><a name="line799"></a> 799     end
</span><span class="uncovered0"><a name="line800"></a> 800   end # class Rake::FileTask
</span><span class="inferred1"><a name="line801"></a> 801 
</span><span class="inferred0"><a name="line802"></a> 802   ###########################################################################
</span><span class="inferred1"><a name="line803"></a> 803   # A FileCreationTask is a file task that when used as a dependency will be
</span><span class="inferred0"><a name="line804"></a> 804   # needed if and only if the file has not been created.  Once created, it is
</span><span class="inferred1"><a name="line805"></a> 805   # not re-triggered if any of its dependencies are newer, nor does trigger
</span><span class="inferred0"><a name="line806"></a> 806   # any rebuilds of tasks that depend on it whenever it is updated.
</span><span class="inferred1"><a name="line807"></a> 807   #
</span><span class="marked0"><a name="line808"></a> 808   class FileCreationTask &lt; FileTask
</span><span class="inferred1"><a name="line809"></a> 809     # Is this file task needed?  Yes if it doesn't exist.
</span><span class="marked0"><a name="line810"></a> 810     def needed?
</span><span class="uncovered1"><a name="line811"></a> 811       ! File.exist?(name)
</span><span class="uncovered0"><a name="line812"></a> 812     end
</span><span class="inferred1"><a name="line813"></a> 813 
</span><span class="inferred0"><a name="line814"></a> 814     # Time stamp for file creation task.  This time stamp is earlier
</span><span class="inferred1"><a name="line815"></a> 815     # than any other time stamp.
</span><span class="marked0"><a name="line816"></a> 816     def timestamp
</span><span class="uncovered1"><a name="line817"></a> 817       Rake::EARLY
</span><span class="uncovered0"><a name="line818"></a> 818     end
</span><span class="uncovered1"><a name="line819"></a> 819   end
</span><span class="inferred0"><a name="line820"></a> 820 
</span><span class="inferred1"><a name="line821"></a> 821   ###########################################################################
</span><span class="inferred0"><a name="line822"></a> 822   # Same as a regular task, but the immediate prerequisites are done in
</span><span class="inferred1"><a name="line823"></a> 823   # parallel using Ruby threads.
</span><span class="inferred0"><a name="line824"></a> 824   #
</span><span class="marked1"><a name="line825"></a> 825   class MultiTask &lt; Task
</span><span class="marked0"><a name="line826"></a> 826     private
</span><span class="marked1"><a name="line827"></a> 827     def invoke_prerequisites(args, invocation_chain)
</span><span class="uncovered0"><a name="line828"></a> 828       threads = @prerequisites.collect { |p|
</span><span class="uncovered1"><a name="line829"></a> 829         Thread.new(p) { |r| application[r].invoke_with_call_chain(args, invocation_chain) }
</span><span class="uncovered0"><a name="line830"></a> 830       }
</span><span class="uncovered1"><a name="line831"></a> 831       threads.each { |t| t.join }
</span><span class="uncovered0"><a name="line832"></a> 832     end
</span><span class="uncovered1"><a name="line833"></a> 833   end
</span><span class="uncovered0"><a name="line834"></a> 834 end # module Rake
</span><span class="inferred1"><a name="line835"></a> 835 
</span><span class="inferred0"><a name="line836"></a> 836 ## ###########################################################################
</span><span class="inferred1"><a name="line837"></a> 837 # Task Definition Functions ...
</span><span class="inferred0"><a name="line838"></a> 838 
</span><span class="inferred1"><a name="line839"></a> 839 # Declare a basic task.
</span><span class="inferred0"><a name="line840"></a> 840 #
</span><span class="inferred1"><a name="line841"></a> 841 # Example:
</span><span class="inferred0"><a name="line842"></a> 842 #   task :clobber =&gt; [:clean] do
</span><span class="inferred1"><a name="line843"></a> 843 #     rm_rf &quot;html&quot;
</span><span class="inferred0"><a name="line844"></a> 844 #   end
</span><span class="inferred1"><a name="line845"></a> 845 #
</span><span class="marked0"><a name="line846"></a> 846 def task(*args, &amp;block)
</span><span class="marked1"><a name="line847"></a> 847   Rake::Task.define_task(*args, &amp;block)
</span><span class="inferred0"><a name="line848"></a> 848 end
</span><span class="inferred1"><a name="line849"></a> 849 
</span><span class="inferred0"><a name="line850"></a> 850 
</span><span class="inferred1"><a name="line851"></a> 851 # Declare a file task.
</span><span class="inferred0"><a name="line852"></a> 852 #
</span><span class="inferred1"><a name="line853"></a> 853 # Example:
</span><span class="inferred0"><a name="line854"></a> 854 #   file &quot;config.cfg&quot; =&gt; [&quot;config.template&quot;] do
</span><span class="inferred1"><a name="line855"></a> 855 #     open(&quot;config.cfg&quot;, &quot;w&quot;) do |outfile|
</span><span class="inferred0"><a name="line856"></a> 856 #       open(&quot;config.template&quot;) do |infile|
</span><span class="inferred1"><a name="line857"></a> 857 #         while line = infile.gets
</span><span class="inferred0"><a name="line858"></a> 858 #           outfile.puts line
</span><span class="inferred1"><a name="line859"></a> 859 #         end
</span><span class="inferred0"><a name="line860"></a> 860 #       end
</span><span class="inferred1"><a name="line861"></a> 861 #     end
</span><span class="inferred0"><a name="line862"></a> 862 #  end
</span><span class="inferred1"><a name="line863"></a> 863 #
</span><span class="marked0"><a name="line864"></a> 864 def file(*args, &amp;block)
</span><span class="uncovered1"><a name="line865"></a> 865   Rake::FileTask.define_task(*args, &amp;block)
</span><span class="uncovered0"><a name="line866"></a> 866 end
</span><span class="inferred1"><a name="line867"></a> 867 
</span><span class="inferred0"><a name="line868"></a> 868 # Declare a file creation task.
</span><span class="inferred1"><a name="line869"></a> 869 # (Mainly used for the directory command).
</span><span class="marked0"><a name="line870"></a> 870 def file_create(args, &amp;block)
</span><span class="uncovered1"><a name="line871"></a> 871   Rake::FileCreationTask.define_task(args, &amp;block)
</span><span class="uncovered0"><a name="line872"></a> 872 end
</span><span class="inferred1"><a name="line873"></a> 873 
</span><span class="inferred0"><a name="line874"></a> 874 # Declare a set of files tasks to create the given directories on demand.
</span><span class="inferred1"><a name="line875"></a> 875 #
</span><span class="inferred0"><a name="line876"></a> 876 # Example:
</span><span class="inferred1"><a name="line877"></a> 877 #   directory &quot;testdata/doc&quot;
</span><span class="inferred0"><a name="line878"></a> 878 #
</span><span class="marked1"><a name="line879"></a> 879 def directory(dir)
</span><span class="uncovered0"><a name="line880"></a> 880   Rake.each_dir_parent(dir) do |d|
</span><span class="uncovered1"><a name="line881"></a> 881     file_create d do |t|
</span><span class="uncovered0"><a name="line882"></a> 882       mkdir_p t.name if ! File.exist?(t.name)
</span><span class="uncovered1"><a name="line883"></a> 883     end
</span><span class="uncovered0"><a name="line884"></a> 884   end
</span><span class="uncovered1"><a name="line885"></a> 885 end
</span><span class="inferred0"><a name="line886"></a> 886 
</span><span class="inferred1"><a name="line887"></a> 887 # Declare a task that performs its prerequisites in parallel. Multitasks does
</span><span class="inferred0"><a name="line888"></a> 888 # *not* guarantee that its prerequisites will execute in any given order
</span><span class="inferred1"><a name="line889"></a> 889 # (which is obvious when you think about it)
</span><span class="inferred0"><a name="line890"></a> 890 #
</span><span class="inferred1"><a name="line891"></a> 891 # Example:
</span><span class="inferred0"><a name="line892"></a> 892 #   multitask :deploy =&gt; [:deploy_gem, :deploy_rdoc]
</span><span class="inferred1"><a name="line893"></a> 893 #
</span><span class="marked0"><a name="line894"></a> 894 def multitask(args, &amp;block)
</span><span class="uncovered1"><a name="line895"></a> 895   Rake::MultiTask.define_task(args, &amp;block)
</span><span class="uncovered0"><a name="line896"></a> 896 end
</span><span class="inferred1"><a name="line897"></a> 897 
</span><span class="inferred0"><a name="line898"></a> 898 # Create a new rake namespace and use it for evaluating the given block.
</span><span class="inferred1"><a name="line899"></a> 899 # Returns a NameSpace object that can be used to lookup tasks defined in the
</span><span class="inferred0"><a name="line900"></a> 900 # namespace.
</span><span class="inferred1"><a name="line901"></a> 901 #
</span><span class="inferred0"><a name="line902"></a> 902 # E.g.
</span><span class="inferred1"><a name="line903"></a> 903 #
</span><span class="inferred0"><a name="line904"></a> 904 #   ns = namespace &quot;nested&quot; do
</span><span class="inferred1"><a name="line905"></a> 905 #     task :run
</span><span class="inferred0"><a name="line906"></a> 906 #   end
</span><span class="inferred1"><a name="line907"></a> 907 #   task_run = ns[:run] # find :run in the given namespace.
</span><span class="inferred0"><a name="line908"></a> 908 #
</span><span class="marked1"><a name="line909"></a> 909 def namespace(name=nil, &amp;block)
</span><span class="uncovered0"><a name="line910"></a> 910   Rake.application.in_namespace(name, &amp;block)
</span><span class="uncovered1"><a name="line911"></a> 911 end
</span><span class="inferred0"><a name="line912"></a> 912 
</span><span class="inferred1"><a name="line913"></a> 913 # Declare a rule for auto-tasks.
</span><span class="inferred0"><a name="line914"></a> 914 #
</span><span class="inferred1"><a name="line915"></a> 915 # Example:
</span><span class="inferred0"><a name="line916"></a> 916 #  rule '.o' =&gt; '.c' do |t|
</span><span class="inferred1"><a name="line917"></a> 917 #    sh %{cc -o #{t.name} #{t.source}}
</span><span class="inferred0"><a name="line918"></a> 918 #  end
</span><span class="inferred1"><a name="line919"></a> 919 #
</span><span class="marked0"><a name="line920"></a> 920 def rule(*args, &amp;block)
</span><span class="uncovered1"><a name="line921"></a> 921   Rake::Task.create_rule(*args, &amp;block)
</span><span class="uncovered0"><a name="line922"></a> 922 end
</span><span class="inferred1"><a name="line923"></a> 923 
</span><span class="inferred0"><a name="line924"></a> 924 # Describe the next rake task.
</span><span class="inferred1"><a name="line925"></a> 925 #
</span><span class="inferred0"><a name="line926"></a> 926 # Example:
</span><span class="inferred1"><a name="line927"></a> 927 #   desc &quot;Run the Unit Tests&quot;
</span><span class="inferred0"><a name="line928"></a> 928 #   task :test =&gt; [:build]
</span><span class="inferred1"><a name="line929"></a> 929 #     runtests
</span><span class="inferred0"><a name="line930"></a> 930 #   end
</span><span class="inferred1"><a name="line931"></a> 931 #
</span><span class="marked0"><a name="line932"></a> 932 def desc(description)
</span><span class="marked1"><a name="line933"></a> 933   Rake.application.last_description = description
</span><span class="marked0"><a name="line934"></a> 934 end
</span><span class="inferred1"><a name="line935"></a> 935 
</span><span class="inferred0"><a name="line936"></a> 936 # Import the partial Rakefiles +fn+.  Imported files are loaded _after_ the
</span><span class="inferred1"><a name="line937"></a> 937 # current file is completely loaded.  This allows the import statement to
</span><span class="inferred0"><a name="line938"></a> 938 # appear anywhere in the importing file, and yet allowing the imported files
</span><span class="inferred1"><a name="line939"></a> 939 # to depend on objects defined in the importing file.
</span><span class="inferred0"><a name="line940"></a> 940 #
</span><span class="inferred1"><a name="line941"></a> 941 # A common use of the import statement is to include files containing
</span><span class="inferred0"><a name="line942"></a> 942 # dependency declarations.
</span><span class="inferred1"><a name="line943"></a> 943 #
</span><span class="inferred0"><a name="line944"></a> 944 # See also the --rakelibdir command line option.
</span><span class="inferred1"><a name="line945"></a> 945 #
</span><span class="inferred0"><a name="line946"></a> 946 # Example:
</span><span class="inferred1"><a name="line947"></a> 947 #   import &quot;.depend&quot;, &quot;my_rules&quot;
</span><span class="inferred0"><a name="line948"></a> 948 #
</span><span class="marked1"><a name="line949"></a> 949 def import(*fns)
</span><span class="uncovered0"><a name="line950"></a> 950   fns.each do |fn|
</span><span class="uncovered1"><a name="line951"></a> 951     Rake.application.add_import(fn)
</span><span class="uncovered0"><a name="line952"></a> 952   end
</span><span class="uncovered1"><a name="line953"></a> 953 end
</span><span class="inferred0"><a name="line954"></a> 954 
</span><span class="inferred1"><a name="line955"></a> 955 #############################################################################
</span><span class="inferred0"><a name="line956"></a> 956 # This a FileUtils extension that defines several additional commands to be
</span><span class="inferred1"><a name="line957"></a> 957 # added to the FileUtils utility functions.
</span><span class="inferred0"><a name="line958"></a> 958 #
</span><span class="marked1"><a name="line959"></a> 959 module FileUtils
</span><span class="marked0"><a name="line960"></a> 960   RUBY_EXT = ((Config::CONFIG['ruby_install_name'] =~ /\.(com|cmd|exe|bat|rb|sh)$/) ?
</span><span class="inferred1"><a name="line961"></a> 961     &quot;&quot; :
</span><span class="uncovered0"><a name="line962"></a> 962     Config::CONFIG['EXEEXT'])
</span><span class="inferred1"><a name="line963"></a> 963   
</span><span class="marked0"><a name="line964"></a> 964   RUBY = File.join(
</span><span class="inferred1"><a name="line965"></a> 965     Config::CONFIG['bindir'],
</span><span class="inferred0"><a name="line966"></a> 966     Config::CONFIG['ruby_install_name'] + RUBY_EXT).
</span><span class="inferred1"><a name="line967"></a> 967     sub(/.*\s.*/m, '&quot;\&amp;&quot;')
</span><span class="inferred0"><a name="line968"></a> 968 
</span><span class="marked1"><a name="line969"></a> 969   OPT_TABLE['sh']  = %w(noop verbose)
</span><span class="marked0"><a name="line970"></a> 970   OPT_TABLE['ruby'] = %w(noop verbose)
</span><span class="inferred1"><a name="line971"></a> 971 
</span><span class="inferred0"><a name="line972"></a> 972   # Run the system command +cmd+. If multiple arguments are given the command
</span><span class="inferred1"><a name="line973"></a> 973   # is not run with the shell (same semantics as Kernel::exec and
</span><span class="inferred0"><a name="line974"></a> 974   # Kernel::system).
</span><span class="inferred1"><a name="line975"></a> 975   #
</span><span class="inferred0"><a name="line976"></a> 976   # Example:
</span><span class="inferred1"><a name="line977"></a> 977   #   sh %{ls -ltr}
</span><span class="inferred0"><a name="line978"></a> 978   #
</span><span class="inferred1"><a name="line979"></a> 979   #   sh 'ls', 'file with spaces'
</span><span class="inferred0"><a name="line980"></a> 980   #
</span><span class="inferred1"><a name="line981"></a> 981   #   # check exit status after command runs
</span><span class="inferred0"><a name="line982"></a> 982   #   sh %{grep pattern file} do |ok, res|
</span><span class="inferred1"><a name="line983"></a> 983   #     if ! ok
</span><span class="inferred0"><a name="line984"></a> 984   #       puts &quot;pattern not found (status = #{res.exitstatus})&quot;
</span><span class="inferred1"><a name="line985"></a> 985   #     end
</span><span class="inferred0"><a name="line986"></a> 986   #   end
</span><span class="inferred1"><a name="line987"></a> 987   #
</span><span class="marked0"><a name="line988"></a> 988   def sh(*cmd, &amp;block)
</span><span class="uncovered1"><a name="line989"></a> 989     options = (Hash === cmd.last) ? cmd.pop : {}
</span><span class="uncovered0"><a name="line990"></a> 990     unless block_given?
</span><span class="uncovered1"><a name="line991"></a> 991       show_command = cmd.join(&quot; &quot;)
</span><span class="uncovered0"><a name="line992"></a> 992       show_command = show_command[0,42] + &quot;...&quot; unless $trace
</span><span class="uncovered1"><a name="line993"></a> 993       # TODO code application logic heref show_command.length &gt; 45
</span><span class="uncovered0"><a name="line994"></a> 994       block = lambda { |ok, status|
</span><span class="uncovered1"><a name="line995"></a> 995         ok or fail &quot;Command failed with status (#{status.exitstatus}): [#{show_command}]&quot;
</span><span class="uncovered0"><a name="line996"></a> 996       }
</span><span class="uncovered1"><a name="line997"></a> 997     end
</span><span class="uncovered0"><a name="line998"></a> 998     if RakeFileUtils.verbose_flag == :default
</span><span class="uncovered1"><a name="line999"></a> 999       options[:verbose] = true
</span><span class="uncovered0"><a name="line1000"></a>1000     else
</span><span class="uncovered1"><a name="line1001"></a>1001       options[:verbose] ||= RakeFileUtils.verbose_flag
</span><span class="uncovered0"><a name="line1002"></a>1002     end
</span><span class="uncovered1"><a name="line1003"></a>1003     options[:noop]    ||= RakeFileUtils.nowrite_flag
</span><span class="uncovered0"><a name="line1004"></a>1004     rake_check_options options, :noop, :verbose
</span><span class="uncovered1"><a name="line1005"></a>1005     rake_output_message cmd.join(&quot; &quot;) if options[:verbose]
</span><span class="uncovered0"><a name="line1006"></a>1006     unless options[:noop]
</span><span class="uncovered1"><a name="line1007"></a>1007       res = rake_system(*cmd)
</span><span class="uncovered0"><a name="line1008"></a>1008       status = $?
</span><span class="uncovered1"><a name="line1009"></a>1009       status = PseudoStatus.new(1) if !res &amp;&amp; status.nil?
</span><span class="uncovered0"><a name="line1010"></a>1010       block.call(res, status)
</span><span class="uncovered1"><a name="line1011"></a>1011     end
</span><span class="uncovered0"><a name="line1012"></a>1012   end
</span><span class="inferred1"><a name="line1013"></a>1013 
</span><span class="marked0"><a name="line1014"></a>1014   def rake_system(*cmd)
</span><span class="uncovered1"><a name="line1015"></a>1015     Rake::AltSystem.system(*cmd)
</span><span class="uncovered0"><a name="line1016"></a>1016   end
</span><span class="marked1"><a name="line1017"></a>1017   private :rake_system
</span><span class="inferred0"><a name="line1018"></a>1018 
</span><span class="inferred1"><a name="line1019"></a>1019   # Run a Ruby interpreter with the given arguments.
</span><span class="inferred0"><a name="line1020"></a>1020   #
</span><span class="inferred1"><a name="line1021"></a>1021   # Example:
</span><span class="inferred0"><a name="line1022"></a>1022   #   ruby %{-pe '$_.upcase!' &lt;README}
</span><span class="inferred1"><a name="line1023"></a>1023   #
</span><span class="marked0"><a name="line1024"></a>1024   def ruby(*args,&amp;block)
</span><span class="uncovered1"><a name="line1025"></a>1025     options = (Hash === args.last) ? args.pop : {}
</span><span class="uncovered0"><a name="line1026"></a>1026     if args.length &gt; 1 then
</span><span class="uncovered1"><a name="line1027"></a>1027       sh(*([RUBY] + args + [options]), &amp;block)
</span><span class="uncovered0"><a name="line1028"></a>1028     else
</span><span class="uncovered1"><a name="line1029"></a>1029       sh(&quot;#{RUBY} #{args.first}&quot;, options, &amp;block)
</span><span class="uncovered0"><a name="line1030"></a>1030     end
</span><span class="uncovered1"><a name="line1031"></a>1031   end
</span><span class="inferred0"><a name="line1032"></a>1032 
</span><span class="marked1"><a name="line1033"></a>1033   LN_SUPPORTED = [true]
</span><span class="inferred0"><a name="line1034"></a>1034 
</span><span class="inferred1"><a name="line1035"></a>1035   #  Attempt to do a normal file link, but fall back to a copy if the link
</span><span class="inferred0"><a name="line1036"></a>1036   #  fails.
</span><span class="marked1"><a name="line1037"></a>1037   def safe_ln(*args)
</span><span class="uncovered0"><a name="line1038"></a>1038     unless LN_SUPPORTED[0]
</span><span class="uncovered1"><a name="line1039"></a>1039       cp(*args)
</span><span class="uncovered0"><a name="line1040"></a>1040     else
</span><span class="uncovered1"><a name="line1041"></a>1041       begin
</span><span class="uncovered0"><a name="line1042"></a>1042         ln(*args)
</span><span class="uncovered1"><a name="line1043"></a>1043       rescue StandardError, NotImplementedError =&gt; ex
</span><span class="uncovered0"><a name="line1044"></a>1044         LN_SUPPORTED[0] = false
</span><span class="uncovered1"><a name="line1045"></a>1045         cp(*args)
</span><span class="uncovered0"><a name="line1046"></a>1046       end
</span><span class="uncovered1"><a name="line1047"></a>1047     end
</span><span class="uncovered0"><a name="line1048"></a>1048   end
</span><span class="inferred1"><a name="line1049"></a>1049 
</span><span class="inferred0"><a name="line1050"></a>1050   # Split a file path into individual directory names.
</span><span class="inferred1"><a name="line1051"></a>1051   #
</span><span class="inferred0"><a name="line1052"></a>1052   # Example:
</span><span class="inferred1"><a name="line1053"></a>1053   #   split_all(&quot;a/b/c&quot;) =&gt;  ['a', 'b', 'c']
</span><span class="inferred0"><a name="line1054"></a>1054   #
</span><span class="marked1"><a name="line1055"></a>1055   def split_all(path)
</span><span class="uncovered0"><a name="line1056"></a>1056     head, tail = File.split(path)
</span><span class="uncovered1"><a name="line1057"></a>1057     return [tail] if head == '.' || tail == '/'
</span><span class="uncovered0"><a name="line1058"></a>1058     return [head, tail] if head == '/'
</span><span class="uncovered1"><a name="line1059"></a>1059     return split_all(head) + [tail]
</span><span class="uncovered0"><a name="line1060"></a>1060   end
</span><span class="uncovered1"><a name="line1061"></a>1061 end
</span><span class="inferred0"><a name="line1062"></a>1062 
</span><span class="inferred1"><a name="line1063"></a>1063 #############################################################################
</span><span class="inferred0"><a name="line1064"></a>1064 # RakeFileUtils provides a custom version of the FileUtils methods that
</span><span class="inferred1"><a name="line1065"></a>1065 # respond to the &lt;tt&gt;verbose&lt;/tt&gt; and &lt;tt&gt;nowrite&lt;/tt&gt; commands.
</span><span class="inferred0"><a name="line1066"></a>1066 #
</span><span class="marked1"><a name="line1067"></a>1067 module RakeFileUtils
</span><span class="marked0"><a name="line1068"></a>1068   include FileUtils
</span><span class="inferred1"><a name="line1069"></a>1069 
</span><span class="marked0"><a name="line1070"></a>1070   class &lt;&lt; self
</span><span class="marked1"><a name="line1071"></a>1071     attr_accessor :verbose_flag, :nowrite_flag
</span><span class="inferred0"><a name="line1072"></a>1072   end
</span><span class="marked1"><a name="line1073"></a>1073   RakeFileUtils.verbose_flag = :default
</span><span class="marked0"><a name="line1074"></a>1074   RakeFileUtils.nowrite_flag = false
</span><span class="inferred1"><a name="line1075"></a>1075 
</span><span class="marked0"><a name="line1076"></a>1076   $fileutils_verbose = true
</span><span class="marked1"><a name="line1077"></a>1077   $fileutils_nowrite = false
</span><span class="inferred0"><a name="line1078"></a>1078 
</span><span class="marked1"><a name="line1079"></a>1079   FileUtils::OPT_TABLE.each do |name, opts|
</span><span class="marked0"><a name="line1080"></a>1080     default_options = []
</span><span class="marked1"><a name="line1081"></a>1081     if opts.include?(:verbose) || opts.include?(&quot;verbose&quot;)
</span><span class="marked0"><a name="line1082"></a>1082       default_options &lt;&lt; ':verbose =&gt; RakeFileUtils.verbose_flag'
</span><span class="inferred1"><a name="line1083"></a>1083     end
</span><span class="marked0"><a name="line1084"></a>1084     if opts.include?(:noop) || opts.include?(&quot;noop&quot;)
</span><span class="marked1"><a name="line1085"></a>1085       default_options &lt;&lt; ':noop =&gt; RakeFileUtils.nowrite_flag'
</span><span class="inferred0"><a name="line1086"></a>1086     end
</span><span class="inferred1"><a name="line1087"></a>1087 
</span><span class="marked0"><a name="line1088"></a>1088     next if default_options.empty?
</span><span class="marked1"><a name="line1089"></a>1089     module_eval(&lt;&lt;-EOS, __FILE__, __LINE__ + 1)
</span><span class="marked0"><a name="line1090"></a>1090     def #{name}( *args, &amp;block )
</span><span class="inferred1"><a name="line1091"></a>1091       super(
</span><span class="inferred0"><a name="line1092"></a>1092         *rake_merge_option(args,
</span><span class="inferred1"><a name="line1093"></a>1093           #{default_options.join(', ')}
</span><span class="inferred0"><a name="line1094"></a>1094           ), &amp;block)
</span><span class="inferred1"><a name="line1095"></a>1095     end
</span><span class="inferred0"><a name="line1096"></a>1096     EOS
</span><span class="inferred1"><a name="line1097"></a>1097   end
</span><span class="inferred0"><a name="line1098"></a>1098 
</span><span class="inferred1"><a name="line1099"></a>1099   # Get/set the verbose flag controlling output from the FileUtils utilities.
</span><span class="inferred0"><a name="line1100"></a>1100   # If verbose is true, then the utility method is echoed to standard output.
</span><span class="inferred1"><a name="line1101"></a>1101   #
</span><span class="inferred0"><a name="line1102"></a>1102   # Examples:
</span><span class="inferred1"><a name="line1103"></a>1103   #    verbose              # return the current value of the verbose flag
</span><span class="inferred0"><a name="line1104"></a>1104   #    verbose(v)           # set the verbose flag to _v_.
</span><span class="inferred1"><a name="line1105"></a>1105   #    verbose(v) { code }  # Execute code with the verbose flag set temporarily to _v_.
</span><span class="inferred0"><a name="line1106"></a>1106   #                         # Return to the original value when code is done.
</span><span class="marked1"><a name="line1107"></a>1107   def verbose(value=nil)
</span><span class="uncovered0"><a name="line1108"></a>1108     oldvalue = RakeFileUtils.verbose_flag
</span><span class="uncovered1"><a name="line1109"></a>1109     RakeFileUtils.verbose_flag = value unless value.nil?
</span><span class="uncovered0"><a name="line1110"></a>1110     if block_given?
</span><span class="uncovered1"><a name="line1111"></a>1111       begin
</span><span class="uncovered0"><a name="line1112"></a>1112         yield
</span><span class="uncovered1"><a name="line1113"></a>1113       ensure
</span><span class="uncovered0"><a name="line1114"></a>1114         RakeFileUtils.verbose_flag = oldvalue
</span><span class="uncovered1"><a name="line1115"></a>1115       end
</span><span class="uncovered0"><a name="line1116"></a>1116     end
</span><span class="uncovered1"><a name="line1117"></a>1117     RakeFileUtils.verbose_flag
</span><span class="uncovered0"><a name="line1118"></a>1118   end
</span><span class="inferred1"><a name="line1119"></a>1119 
</span><span class="inferred0"><a name="line1120"></a>1120   # Get/set the nowrite flag controlling output from the FileUtils utilities.
</span><span class="inferred1"><a name="line1121"></a>1121   # If verbose is true, then the utility method is echoed to standard output.
</span><span class="inferred0"><a name="line1122"></a>1122   #
</span><span class="inferred1"><a name="line1123"></a>1123   # Examples:
</span><span class="inferred0"><a name="line1124"></a>1124   #    nowrite              # return the current value of the nowrite flag
</span><span class="inferred1"><a name="line1125"></a>1125   #    nowrite(v)           # set the nowrite flag to _v_.
</span><span class="inferred0"><a name="line1126"></a>1126   #    nowrite(v) { code }  # Execute code with the nowrite flag set temporarily to _v_.
</span><span class="inferred1"><a name="line1127"></a>1127   #                         # Return to the original value when code is done.
</span><span class="marked0"><a name="line1128"></a>1128   def nowrite(value=nil)
</span><span class="uncovered1"><a name="line1129"></a>1129     oldvalue = RakeFileUtils.nowrite_flag
</span><span class="uncovered0"><a name="line1130"></a>1130     RakeFileUtils.nowrite_flag = value unless value.nil?
</span><span class="uncovered1"><a name="line1131"></a>1131     if block_given?
</span><span class="uncovered0"><a name="line1132"></a>1132       begin
</span><span class="uncovered1"><a name="line1133"></a>1133         yield
</span><span class="uncovered0"><a name="line1134"></a>1134       ensure
</span><span class="uncovered1"><a name="line1135"></a>1135         RakeFileUtils.nowrite_flag = oldvalue
</span><span class="uncovered0"><a name="line1136"></a>1136       end
</span><span class="uncovered1"><a name="line1137"></a>1137     end
</span><span class="uncovered0"><a name="line1138"></a>1138     oldvalue
</span><span class="uncovered1"><a name="line1139"></a>1139   end
</span><span class="inferred0"><a name="line1140"></a>1140 
</span><span class="inferred1"><a name="line1141"></a>1141   # Use this function to prevent protentially destructive ruby code from
</span><span class="inferred0"><a name="line1142"></a>1142   # running when the :nowrite flag is set.
</span><span class="inferred1"><a name="line1143"></a>1143   #
</span><span class="inferred0"><a name="line1144"></a>1144   # Example:
</span><span class="inferred1"><a name="line1145"></a>1145   #
</span><span class="inferred0"><a name="line1146"></a>1146   #   when_writing(&quot;Building Project&quot;) do
</span><span class="inferred1"><a name="line1147"></a>1147   #     project.build
</span><span class="inferred0"><a name="line1148"></a>1148   #   end
</span><span class="inferred1"><a name="line1149"></a>1149   #
</span><span class="inferred0"><a name="line1150"></a>1150   # The following code will build the project under normal conditions. If the
</span><span class="inferred1"><a name="line1151"></a>1151   # nowrite(true) flag is set, then the example will print:
</span><span class="inferred0"><a name="line1152"></a>1152   #      DRYRUN: Building Project
</span><span class="inferred1"><a name="line1153"></a>1153   # instead of actually building the project.
</span><span class="inferred0"><a name="line1154"></a>1154   #
</span><span class="marked1"><a name="line1155"></a>1155   def when_writing(msg=nil)
</span><span class="uncovered0"><a name="line1156"></a>1156     if RakeFileUtils.nowrite_flag
</span><span class="uncovered1"><a name="line1157"></a>1157       puts &quot;DRYRUN: #{msg}&quot; if msg
</span><span class="uncovered0"><a name="line1158"></a>1158     else
</span><span class="uncovered1"><a name="line1159"></a>1159       yield
</span><span class="uncovered0"><a name="line1160"></a>1160     end
</span><span class="uncovered1"><a name="line1161"></a>1161   end
</span><span class="inferred0"><a name="line1162"></a>1162 
</span><span class="inferred1"><a name="line1163"></a>1163   # Merge the given options with the default values.
</span><span class="marked0"><a name="line1164"></a>1164   def rake_merge_option(args, defaults)
</span><span class="uncovered1"><a name="line1165"></a>1165     if Hash === args.last
</span><span class="uncovered0"><a name="line1166"></a>1166       defaults.update(args.last)
</span><span class="uncovered1"><a name="line1167"></a>1167       args.pop
</span><span class="uncovered0"><a name="line1168"></a>1168     end
</span><span class="uncovered1"><a name="line1169"></a>1169     args.push defaults
</span><span class="uncovered0"><a name="line1170"></a>1170     args
</span><span class="uncovered1"><a name="line1171"></a>1171   end
</span><span class="marked0"><a name="line1172"></a>1172   private :rake_merge_option
</span><span class="inferred1"><a name="line1173"></a>1173 
</span><span class="inferred0"><a name="line1174"></a>1174   # Send the message to the default rake output (which is $stderr).
</span><span class="marked1"><a name="line1175"></a>1175   def rake_output_message(message)
</span><span class="uncovered0"><a name="line1176"></a>1176     $stderr.puts(message)
</span><span class="uncovered1"><a name="line1177"></a>1177   end
</span><span class="marked0"><a name="line1178"></a>1178   private :rake_output_message
</span><span class="inferred1"><a name="line1179"></a>1179 
</span><span class="inferred0"><a name="line1180"></a>1180   # Check that the options do not contain options not listed in +optdecl+.  An
</span><span class="inferred1"><a name="line1181"></a>1181   # ArgumentError exception is thrown if non-declared options are found.
</span><span class="marked0"><a name="line1182"></a>1182   def rake_check_options(options, *optdecl)
</span><span class="uncovered1"><a name="line1183"></a>1183     h = options.dup
</span><span class="uncovered0"><a name="line1184"></a>1184     optdecl.each do |name|
</span><span class="uncovered1"><a name="line1185"></a>1185       h.delete name
</span><span class="uncovered0"><a name="line1186"></a>1186     end
</span><span class="uncovered1"><a name="line1187"></a>1187     raise ArgumentError, &quot;no such option: #{h.keys.join(' ')}&quot; unless h.empty?
</span><span class="uncovered0"><a name="line1188"></a>1188   end
</span><span class="marked1"><a name="line1189"></a>1189   private :rake_check_options
</span><span class="inferred0"><a name="line1190"></a>1190 
</span><span class="marked1"><a name="line1191"></a>1191   extend self
</span><span class="inferred0"><a name="line1192"></a>1192 end
</span><span class="inferred1"><a name="line1193"></a>1193 
</span><span class="inferred0"><a name="line1194"></a>1194 #############################################################################
</span><span class="inferred1"><a name="line1195"></a>1195 # Include the FileUtils file manipulation functions in the top level module,
</span><span class="inferred0"><a name="line1196"></a>1196 # but mark them private so that they don't unintentionally define methods on
</span><span class="inferred1"><a name="line1197"></a>1197 # other objects.
</span><span class="inferred0"><a name="line1198"></a>1198 
</span><span class="marked1"><a name="line1199"></a>1199 include RakeFileUtils
</span><span class="marked0"><a name="line1200"></a>1200 private(*FileUtils.instance_methods(false))
</span><span class="marked1"><a name="line1201"></a>1201 private(*RakeFileUtils.instance_methods(false))
</span><span class="inferred0"><a name="line1202"></a>1202 
</span><span class="inferred1"><a name="line1203"></a>1203 ######################################################################
</span><span class="marked0"><a name="line1204"></a>1204 module Rake
</span><span class="inferred1"><a name="line1205"></a>1205 
</span><span class="inferred0"><a name="line1206"></a>1206   ###########################################################################
</span><span class="inferred1"><a name="line1207"></a>1207   # A FileList is essentially an array with a few helper methods defined to
</span><span class="inferred0"><a name="line1208"></a>1208   # make file manipulation a bit easier.
</span><span class="inferred1"><a name="line1209"></a>1209   #
</span><span class="inferred0"><a name="line1210"></a>1210   # FileLists are lazy.  When given a list of glob patterns for possible files
</span><span class="inferred1"><a name="line1211"></a>1211   # to be included in the file list, instead of searching the file structures
</span><span class="inferred0"><a name="line1212"></a>1212   # to find the files, a FileList holds the pattern for latter use.
</span><span class="inferred1"><a name="line1213"></a>1213   #
</span><span class="inferred0"><a name="line1214"></a>1214   # This allows us to define a number of FileList to match any number of
</span><span class="inferred1"><a name="line1215"></a>1215   # files, but only search out the actual files when then FileList itself is
</span><span class="inferred0"><a name="line1216"></a>1216   # actually used.  The key is that the first time an element of the
</span><span class="inferred1"><a name="line1217"></a>1217   # FileList/Array is requested, the pending patterns are resolved into a real
</span><span class="inferred0"><a name="line1218"></a>1218   # list of file names.
</span><span class="inferred1"><a name="line1219"></a>1219   #
</span><span class="marked0"><a name="line1220"></a>1220   class FileList
</span><span class="inferred1"><a name="line1221"></a>1221 
</span><span class="marked0"><a name="line1222"></a>1222     include Cloneable
</span><span class="inferred1"><a name="line1223"></a>1223 
</span><span class="inferred0"><a name="line1224"></a>1224     # == Method Delegation
</span><span class="inferred1"><a name="line1225"></a>1225     #
</span><span class="inferred0"><a name="line1226"></a>1226     # The lazy evaluation magic of FileLists happens by implementing all the
</span><span class="inferred1"><a name="line1227"></a>1227     # array specific methods to call +resolve+ before delegating the heavy
</span><span class="inferred0"><a name="line1228"></a>1228     # lifting to an embedded array object (@items).
</span><span class="inferred1"><a name="line1229"></a>1229     #
</span><span class="inferred0"><a name="line1230"></a>1230     # In addition, there are two kinds of delegation calls.  The regular kind
</span><span class="inferred1"><a name="line1231"></a>1231     # delegates to the @items array and returns the result directly.  Well,
</span><span class="inferred0"><a name="line1232"></a>1232     # almost directly.  It checks if the returned value is the @items object
</span><span class="inferred1"><a name="line1233"></a>1233     # itself, and if so will return the FileList object instead.
</span><span class="inferred0"><a name="line1234"></a>1234     #
</span><span class="inferred1"><a name="line1235"></a>1235     # The second kind of delegation call is used in methods that normally
</span><span class="inferred0"><a name="line1236"></a>1236     # return a new Array object.  We want to capture the return value of these
</span><span class="inferred1"><a name="line1237"></a>1237     # methods and wrap them in a new FileList object.  We enumerate these
</span><span class="inferred0"><a name="line1238"></a>1238     # methods in the +SPECIAL_RETURN+ list below.
</span><span class="inferred1"><a name="line1239"></a>1239 
</span><span class="inferred0"><a name="line1240"></a>1240     # List of array methods (that are not in +Object+) that need to be
</span><span class="inferred1"><a name="line1241"></a>1241     # delegated.
</span><span class="marked0"><a name="line1242"></a>1242     ARRAY_METHODS = (Array.instance_methods - Object.instance_methods).map { |n| n.to_s }
</span><span class="inferred1"><a name="line1243"></a>1243 
</span><span class="inferred0"><a name="line1244"></a>1244     # List of additional methods that must be delegated.
</span><span class="marked1"><a name="line1245"></a>1245     MUST_DEFINE = %w[to_a inspect]
</span><span class="inferred0"><a name="line1246"></a>1246 
</span><span class="inferred1"><a name="line1247"></a>1247     # List of methods that should not be delegated here (we define special
</span><span class="inferred0"><a name="line1248"></a>1248     # versions of them explicitly below).
</span><span class="marked1"><a name="line1249"></a>1249     MUST_NOT_DEFINE = %w[to_a to_ary partition *]
</span><span class="inferred0"><a name="line1250"></a>1250 
</span><span class="inferred1"><a name="line1251"></a>1251     # List of delegated methods that return new array values which need
</span><span class="inferred0"><a name="line1252"></a>1252     # wrapping.
</span><span class="marked1"><a name="line1253"></a>1253     SPECIAL_RETURN = %w[
</span><span class="inferred0"><a name="line1254"></a>1254       map collect sort sort_by select find_all reject grep
</span><span class="inferred1"><a name="line1255"></a>1255       compact flatten uniq values_at
</span><span class="inferred0"><a name="line1256"></a>1256       + - &amp; |
</span><span class="inferred1"><a name="line1257"></a>1257     ]
</span><span class="inferred0"><a name="line1258"></a>1258 
</span><span class="marked1"><a name="line1259"></a>1259     DELEGATING_METHODS = (ARRAY_METHODS + MUST_DEFINE - MUST_NOT_DEFINE).collect{ |s| s.to_s }.sort.uniq
</span><span class="inferred0"><a name="line1260"></a>1260 
</span><span class="inferred1"><a name="line1261"></a>1261     # Now do the delegation.
</span><span class="marked0"><a name="line1262"></a>1262     DELEGATING_METHODS.each_with_index do |sym, i|
</span><span class="marked1"><a name="line1263"></a>1263       if SPECIAL_RETURN.include?(sym)
</span><span class="marked0"><a name="line1264"></a>1264         ln = __LINE__+1
</span><span class="inferred1"><a name="line1265"></a>1265         class_eval %{
</span><span class="marked0"><a name="line1266"></a>1266           def #{sym}(*args, &amp;block)
</span><span class="uncovered1"><a name="line1267"></a>1267             resolve
</span><span class="uncovered0"><a name="line1268"></a>1268             result = @items.send(:#{sym}, *args, &amp;block)
</span><span class="uncovered1"><a name="line1269"></a>1269             FileList.new.import(result)
</span><span class="uncovered0"><a name="line1270"></a>1270           end
</span><span class="marked1"><a name="line1271"></a>1271         }, __FILE__, ln
</span><span class="inferred0"><a name="line1272"></a>1272       else
</span><span class="marked1"><a name="line1273"></a>1273         ln = __LINE__+1
</span><span class="inferred0"><a name="line1274"></a>1274         class_eval %{
</span><span class="marked1"><a name="line1275"></a>1275           def #{sym}(*args, &amp;block)
</span><span class="uncovered0"><a name="line1276"></a>1276             resolve
</span><span class="uncovered1"><a name="line1277"></a>1277             result = @items.send(:#{sym}, *args, &amp;block)
</span><span class="uncovered0"><a name="line1278"></a>1278             result.object_id == @items.object_id ? self : result
</span><span class="uncovered1"><a name="line1279"></a>1279           end
</span><span class="marked0"><a name="line1280"></a>1280         }, __FILE__, ln
</span><span class="inferred1"><a name="line1281"></a>1281       end
</span><span class="inferred0"><a name="line1282"></a>1282     end
</span><span class="inferred1"><a name="line1283"></a>1283 
</span><span class="inferred0"><a name="line1284"></a>1284     # Create a file list from the globbable patterns given.  If you wish to
</span><span class="inferred1"><a name="line1285"></a>1285     # perform multiple includes or excludes at object build time, use the
</span><span class="inferred0"><a name="line1286"></a>1286     # &quot;yield self&quot; pattern.
</span><span class="inferred1"><a name="line1287"></a>1287     #
</span><span class="inferred0"><a name="line1288"></a>1288     # Example:
</span><span class="inferred1"><a name="line1289"></a>1289     #   file_list = FileList.new('lib/**/*.rb', 'test/test*.rb')
</span><span class="inferred0"><a name="line1290"></a>1290     #
</span><span class="inferred1"><a name="line1291"></a>1291     #   pkg_files = FileList.new('lib/**/*') do |fl|
</span><span class="inferred0"><a name="line1292"></a>1292     #     fl.exclude(/\bCVS\b/)
</span><span class="inferred1"><a name="line1293"></a>1293     #   end
</span><span class="inferred0"><a name="line1294"></a>1294     #
</span><span class="marked1"><a name="line1295"></a>1295     def initialize(*patterns)
</span><span class="marked0"><a name="line1296"></a>1296       @pending_add = []
</span><span class="marked1"><a name="line1297"></a>1297       @pending = false
</span><span class="marked0"><a name="line1298"></a>1298       @exclude_patterns = DEFAULT_IGNORE_PATTERNS.dup
</span><span class="marked1"><a name="line1299"></a>1299       @exclude_procs = DEFAULT_IGNORE_PROCS.dup
</span><span class="marked0"><a name="line1300"></a>1300       @exclude_re = nil
</span><span class="marked1"><a name="line1301"></a>1301       @items = []
</span><span class="marked0"><a name="line1302"></a>1302       patterns.each { |pattern| include(pattern) }
</span><span class="marked1"><a name="line1303"></a>1303       yield self if block_given?
</span><span class="inferred0"><a name="line1304"></a>1304     end
</span><span class="inferred1"><a name="line1305"></a>1305 
</span><span class="inferred0"><a name="line1306"></a>1306     # Add file names defined by glob patterns to the file list.  If an array
</span><span class="inferred1"><a name="line1307"></a>1307     # is given, add each element of the array.
</span><span class="inferred0"><a name="line1308"></a>1308     #
</span><span class="inferred1"><a name="line1309"></a>1309     # Example:
</span><span class="inferred0"><a name="line1310"></a>1310     #   file_list.include(&quot;*.java&quot;, &quot;*.cfg&quot;)
</span><span class="inferred1"><a name="line1311"></a>1311     #   file_list.include %w( math.c lib.h *.o )
</span><span class="inferred0"><a name="line1312"></a>1312     #
</span><span class="marked1"><a name="line1313"></a>1313     def include(*filenames)
</span><span class="inferred0"><a name="line1314"></a>1314       # TODO: check for pending
</span><span class="marked1"><a name="line1315"></a>1315       filenames.each do |fn|
</span><span class="marked0"><a name="line1316"></a>1316         if fn.respond_to? :to_ary
</span><span class="uncovered1"><a name="line1317"></a>1317           include(*fn.to_ary)
</span><span class="inferred0"><a name="line1318"></a>1318         else
</span><span class="marked1"><a name="line1319"></a>1319           @pending_add &lt;&lt; fn
</span><span class="inferred0"><a name="line1320"></a>1320         end
</span><span class="inferred1"><a name="line1321"></a>1321       end
</span><span class="marked0"><a name="line1322"></a>1322       @pending = true
</span><span class="marked1"><a name="line1323"></a>1323       self
</span><span class="inferred0"><a name="line1324"></a>1324     end
</span><span class="marked1"><a name="line1325"></a>1325     alias :add :include
</span><span class="inferred0"><a name="line1326"></a>1326 
</span><span class="inferred1"><a name="line1327"></a>1327     # Register a list of file name patterns that should be excluded from the
</span><span class="inferred0"><a name="line1328"></a>1328     # list.  Patterns may be regular expressions, glob patterns or regular
</span><span class="inferred1"><a name="line1329"></a>1329     # strings.  In addition, a block given to exclude will remove entries that
</span><span class="inferred0"><a name="line1330"></a>1330     # return true when given to the block.
</span><span class="inferred1"><a name="line1331"></a>1331     #
</span><span class="inferred0"><a name="line1332"></a>1332     # Note that glob patterns are expanded against the file system. If a file
</span><span class="inferred1"><a name="line1333"></a>1333     # is explicitly added to a file list, but does not exist in the file
</span><span class="inferred0"><a name="line1334"></a>1334     # system, then an glob pattern in the exclude list will not exclude the
</span><span class="inferred1"><a name="line1335"></a>1335     # file.
</span><span class="inferred0"><a name="line1336"></a>1336     #
</span><span class="inferred1"><a name="line1337"></a>1337     # Examples:
</span><span class="inferred0"><a name="line1338"></a>1338     #   FileList['a.c', 'b.c'].exclude(&quot;a.c&quot;) =&gt; ['b.c']
</span><span class="inferred1"><a name="line1339"></a>1339     #   FileList['a.c', 'b.c'].exclude(/^a/)  =&gt; ['b.c']
</span><span class="inferred0"><a name="line1340"></a>1340     #
</span><span class="inferred1"><a name="line1341"></a>1341     # If &quot;a.c&quot; is a file, then ...
</span><span class="inferred0"><a name="line1342"></a>1342     #   FileList['a.c', 'b.c'].exclude(&quot;a.*&quot;) =&gt; ['b.c']
</span><span class="inferred1"><a name="line1343"></a>1343     #
</span><span class="inferred0"><a name="line1344"></a>1344     # If &quot;a.c&quot; is not a file, then ...
</span><span class="inferred1"><a name="line1345"></a>1345     #   FileList['a.c', 'b.c'].exclude(&quot;a.*&quot;) =&gt; ['a.c', 'b.c']
</span><span class="inferred0"><a name="line1346"></a>1346     #
</span><span class="marked1"><a name="line1347"></a>1347     def exclude(*patterns, &amp;block)
</span><span class="uncovered0"><a name="line1348"></a>1348       patterns.each do |pat|
</span><span class="uncovered1"><a name="line1349"></a>1349         @exclude_patterns &lt;&lt; pat
</span><span class="uncovered0"><a name="line1350"></a>1350       end
</span><span class="uncovered1"><a name="line1351"></a>1351       if block_given?
</span><span class="uncovered0"><a name="line1352"></a>1352         @exclude_procs &lt;&lt; block
</span><span class="uncovered1"><a name="line1353"></a>1353       end
</span><span class="uncovered0"><a name="line1354"></a>1354       resolve_exclude if ! @pending
</span><span class="uncovered1"><a name="line1355"></a>1355       self
</span><span class="uncovered0"><a name="line1356"></a>1356     end
</span><span class="inferred1"><a name="line1357"></a>1357 
</span><span class="inferred0"><a name="line1358"></a>1358 
</span><span class="inferred1"><a name="line1359"></a>1359     # Clear all the exclude patterns so that we exclude nothing.
</span><span class="marked0"><a name="line1360"></a>1360     def clear_exclude
</span><span class="uncovered1"><a name="line1361"></a>1361       @exclude_patterns = []
</span><span class="uncovered0"><a name="line1362"></a>1362       @exclude_procs = []
</span><span class="uncovered1"><a name="line1363"></a>1363       calculate_exclude_regexp if ! @pending
</span><span class="uncovered0"><a name="line1364"></a>1364       self
</span><span class="uncovered1"><a name="line1365"></a>1365     end
</span><span class="inferred0"><a name="line1366"></a>1366 
</span><span class="inferred1"><a name="line1367"></a>1367     # Define equality.
</span><span class="marked0"><a name="line1368"></a>1368     def ==(array)
</span><span class="uncovered1"><a name="line1369"></a>1369       to_ary == array
</span><span class="uncovered0"><a name="line1370"></a>1370     end
</span><span class="inferred1"><a name="line1371"></a>1371 
</span><span class="inferred0"><a name="line1372"></a>1372     # Return the internal array object.
</span><span class="marked1"><a name="line1373"></a>1373     def to_a
</span><span class="uncovered0"><a name="line1374"></a>1374       resolve
</span><span class="uncovered1"><a name="line1375"></a>1375       @items
</span><span class="uncovered0"><a name="line1376"></a>1376     end
</span><span class="inferred1"><a name="line1377"></a>1377 
</span><span class="inferred0"><a name="line1378"></a>1378     # Return the internal array object.
</span><span class="marked1"><a name="line1379"></a>1379     def to_ary
</span><span class="uncovered0"><a name="line1380"></a>1380       to_a
</span><span class="uncovered1"><a name="line1381"></a>1381     end
</span><span class="inferred0"><a name="line1382"></a>1382 
</span><span class="inferred1"><a name="line1383"></a>1383     # Lie about our class.
</span><span class="marked0"><a name="line1384"></a>1384     def is_a?(klass)
</span><span class="uncovered1"><a name="line1385"></a>1385       klass == Array || super(klass)
</span><span class="uncovered0"><a name="line1386"></a>1386     end
</span><span class="marked1"><a name="line1387"></a>1387     alias kind_of? is_a?
</span><span class="inferred0"><a name="line1388"></a>1388 
</span><span class="inferred1"><a name="line1389"></a>1389     # Redefine * to return either a string or a new file list.
</span><span class="marked0"><a name="line1390"></a>1390     def *(other)
</span><span class="uncovered1"><a name="line1391"></a>1391       result = @items * other
</span><span class="uncovered0"><a name="line1392"></a>1392       case result
</span><span class="uncovered1"><a name="line1393"></a>1393       when Array
</span><span class="uncovered0"><a name="line1394"></a>1394         FileList.new.import(result)
</span><span class="uncovered1"><a name="line1395"></a>1395       else
</span><span class="uncovered0"><a name="line1396"></a>1396         result
</span><span class="uncovered1"><a name="line1397"></a>1397       end
</span><span class="uncovered0"><a name="line1398"></a>1398     end
</span><span class="inferred1"><a name="line1399"></a>1399 
</span><span class="inferred0"><a name="line1400"></a>1400     # Resolve all the pending adds now.
</span><span class="marked1"><a name="line1401"></a>1401     def resolve
</span><span class="uncovered0"><a name="line1402"></a>1402       if @pending
</span><span class="uncovered1"><a name="line1403"></a>1403         @pending = false
</span><span class="uncovered0"><a name="line1404"></a>1404         @pending_add.each do |fn| resolve_add(fn) end
</span><span class="uncovered1"><a name="line1405"></a>1405         @pending_add = []
</span><span class="uncovered0"><a name="line1406"></a>1406         resolve_exclude
</span><span class="uncovered1"><a name="line1407"></a>1407       end
</span><span class="uncovered0"><a name="line1408"></a>1408       self
</span><span class="uncovered1"><a name="line1409"></a>1409     end
</span><span class="inferred0"><a name="line1410"></a>1410 
</span><span class="marked1"><a name="line1411"></a>1411     def calculate_exclude_regexp
</span><span class="uncovered0"><a name="line1412"></a>1412       ignores = []
</span><span class="uncovered1"><a name="line1413"></a>1413       @exclude_patterns.each do |pat|
</span><span class="uncovered0"><a name="line1414"></a>1414         case pat
</span><span class="uncovered1"><a name="line1415"></a>1415         when Regexp
</span><span class="uncovered0"><a name="line1416"></a>1416           ignores &lt;&lt; pat
</span><span class="uncovered1"><a name="line1417"></a>1417         when /[*?]/
</span><span class="uncovered0"><a name="line1418"></a>1418           Dir[pat].each do |p| ignores &lt;&lt; p end
</span><span class="uncovered1"><a name="line1419"></a>1419         else
</span><span class="uncovered0"><a name="line1420"></a>1420           ignores &lt;&lt; Regexp.quote(pat)
</span><span class="uncovered1"><a name="line1421"></a>1421         end
</span><span class="uncovered0"><a name="line1422"></a>1422       end
</span><span class="uncovered1"><a name="line1423"></a>1423       if ignores.empty?
</span><span class="uncovered0"><a name="line1424"></a>1424         @exclude_re = /^$/
</span><span class="uncovered1"><a name="line1425"></a>1425       else
</span><span class="uncovered0"><a name="line1426"></a>1426         re_str = ignores.collect { |p| &quot;(&quot; + p.to_s + &quot;)&quot; }.join(&quot;|&quot;)
</span><span class="uncovered1"><a name="line1427"></a>1427         @exclude_re = Regexp.new(re_str)
</span><span class="uncovered0"><a name="line1428"></a>1428       end
</span><span class="uncovered1"><a name="line1429"></a>1429     end
</span><span class="inferred0"><a name="line1430"></a>1430 
</span><span class="marked1"><a name="line1431"></a>1431     def resolve_add(fn)
</span><span class="uncovered0"><a name="line1432"></a>1432       case fn
</span><span class="inferred1"><a name="line1433"></a>1433       when %r{[*?\[\{]}
</span><span class="inferred0"><a name="line1434"></a>1434         add_matching(fn)
</span><span class="inferred1"><a name="line1435"></a>1435       else
</span><span class="inferred0"><a name="line1436"></a>1436         self &lt;&lt; fn
</span><span class="inferred1"><a name="line1437"></a>1437       end
</span><span class="inferred0"><a name="line1438"></a>1438     end
</span><span class="marked1"><a name="line1439"></a>1439     private :resolve_add
</span><span class="inferred0"><a name="line1440"></a>1440 
</span><span class="marked1"><a name="line1441"></a>1441     def resolve_exclude
</span><span class="uncovered0"><a name="line1442"></a>1442       calculate_exclude_regexp
</span><span class="uncovered1"><a name="line1443"></a>1443       reject! { |fn| exclude?(fn) }
</span><span class="uncovered0"><a name="line1444"></a>1444       self
</span><span class="uncovered1"><a name="line1445"></a>1445     end
</span><span class="marked0"><a name="line1446"></a>1446     private :resolve_exclude
</span><span class="inferred1"><a name="line1447"></a>1447 
</span><span class="inferred0"><a name="line1448"></a>1448     # Return a new FileList with the results of running +sub+ against each
</span><span class="inferred1"><a name="line1449"></a>1449     # element of the oringal list.
</span><span class="inferred0"><a name="line1450"></a>1450     #
</span><span class="inferred1"><a name="line1451"></a>1451     # Example:
</span><span class="inferred0"><a name="line1452"></a>1452     #   FileList['a.c', 'b.c'].sub(/\.c$/, '.o')  =&gt; ['a.o', 'b.o']
</span><span class="inferred1"><a name="line1453"></a>1453     #
</span><span class="marked0"><a name="line1454"></a>1454     def sub(pat, rep)
</span><span class="uncovered1"><a name="line1455"></a>1455       inject(FileList.new) { |res, fn| res &lt;&lt; fn.sub(pat,rep) }
</span><span class="uncovered0"><a name="line1456"></a>1456     end
</span><span class="inferred1"><a name="line1457"></a>1457 
</span><span class="inferred0"><a name="line1458"></a>1458     # Return a new FileList with the results of running +gsub+ against each
</span><span class="inferred1"><a name="line1459"></a>1459     # element of the original list.
</span><span class="inferred0"><a name="line1460"></a>1460     #
</span><span class="inferred1"><a name="line1461"></a>1461     # Example:
</span><span class="inferred0"><a name="line1462"></a>1462     #   FileList['lib/test/file', 'x/y'].gsub(/\//, &quot;\\&quot;)
</span><span class="inferred1"><a name="line1463"></a>1463     #      =&gt; ['lib\\test\\file', 'x\\y']
</span><span class="inferred0"><a name="line1464"></a>1464     #
</span><span class="marked1"><a name="line1465"></a>1465     def gsub(pat, rep)
</span><span class="uncovered0"><a name="line1466"></a>1466       inject(FileList.new) { |res, fn| res &lt;&lt; fn.gsub(pat,rep) }
</span><span class="uncovered1"><a name="line1467"></a>1467     end
</span><span class="inferred0"><a name="line1468"></a>1468 
</span><span class="inferred1"><a name="line1469"></a>1469     # Same as +sub+ except that the oringal file list is modified.
</span><span class="marked0"><a name="line1470"></a>1470     def sub!(pat, rep)
</span><span class="uncovered1"><a name="line1471"></a>1471       each_with_index { |fn, i| self[i] = fn.sub(pat,rep) }
</span><span class="uncovered0"><a name="line1472"></a>1472       self
</span><span class="uncovered1"><a name="line1473"></a>1473     end
</span><span class="inferred0"><a name="line1474"></a>1474 
</span><span class="inferred1"><a name="line1475"></a>1475     # Same as +gsub+ except that the original file list is modified.
</span><span class="marked0"><a name="line1476"></a>1476     def gsub!(pat, rep)
</span><span class="uncovered1"><a name="line1477"></a>1477       each_with_index { |fn, i| self[i] = fn.gsub(pat,rep) }
</span><span class="uncovered0"><a name="line1478"></a>1478       self
</span><span class="uncovered1"><a name="line1479"></a>1479     end
</span><span class="inferred0"><a name="line1480"></a>1480 
</span><span class="inferred1"><a name="line1481"></a>1481     # Apply the pathmap spec to each of the included file names, returning a
</span><span class="inferred0"><a name="line1482"></a>1482     # new file list with the modified paths.  (See String#pathmap for
</span><span class="inferred1"><a name="line1483"></a>1483     # details.)
</span><span class="marked0"><a name="line1484"></a>1484     def pathmap(spec=nil)
</span><span class="uncovered1"><a name="line1485"></a>1485       collect { |fn| fn.pathmap(spec) }
</span><span class="uncovered0"><a name="line1486"></a>1486     end
</span><span class="inferred1"><a name="line1487"></a>1487 
</span><span class="inferred0"><a name="line1488"></a>1488     # Return a new FileList with &lt;tt&gt;String#ext&lt;/tt&gt; method applied
</span><span class="inferred1"><a name="line1489"></a>1489     # to each member of the array.
</span><span class="inferred0"><a name="line1490"></a>1490     #
</span><span class="inferred1"><a name="line1491"></a>1491     # This method is a shortcut for:
</span><span class="inferred0"><a name="line1492"></a>1492     #
</span><span class="inferred1"><a name="line1493"></a>1493     #    array.collect { |item| item.ext(newext) }
</span><span class="inferred0"><a name="line1494"></a>1494     #
</span><span class="inferred1"><a name="line1495"></a>1495     # +ext+ is a user added method for the Array class.
</span><span class="marked0"><a name="line1496"></a>1496     def ext(newext='')
</span><span class="uncovered1"><a name="line1497"></a>1497       collect { |fn| fn.ext(newext) }
</span><span class="uncovered0"><a name="line1498"></a>1498     end
</span><span class="inferred1"><a name="line1499"></a>1499 
</span><span class="inferred0"><a name="line1500"></a>1500 
</span><span class="inferred1"><a name="line1501"></a>1501     # Grep each of the files in the filelist using the given pattern. If a
</span><span class="inferred0"><a name="line1502"></a>1502     # block is given, call the block on each matching line, passing the file
</span><span class="inferred1"><a name="line1503"></a>1503     # name, line number, and the matching line of text.  If no block is given,
</span><span class="inferred0"><a name="line1504"></a>1504     # a standard emac style file:linenumber:line message will be printed to
</span><span class="inferred1"><a name="line1505"></a>1505     # standard out.
</span><span class="marked0"><a name="line1506"></a>1506     def egrep(pattern, *options)
</span><span class="uncovered1"><a name="line1507"></a>1507       each do |fn|
</span><span class="uncovered0"><a name="line1508"></a>1508         open(fn, &quot;rb&quot;, *options) do |inf|
</span><span class="uncovered1"><a name="line1509"></a>1509           count = 0
</span><span class="uncovered0"><a name="line1510"></a>1510           inf.each do |line|
</span><span class="uncovered1"><a name="line1511"></a>1511             count += 1
</span><span class="uncovered0"><a name="line1512"></a>1512             if pattern.match(line)
</span><span class="uncovered1"><a name="line1513"></a>1513               if block_given?
</span><span class="uncovered0"><a name="line1514"></a>1514                 yield fn, count, line
</span><span class="uncovered1"><a name="line1515"></a>1515               else
</span><span class="uncovered0"><a name="line1516"></a>1516                 puts &quot;#{fn}:#{count}:#{line}&quot;
</span><span class="uncovered1"><a name="line1517"></a>1517               end
</span><span class="uncovered0"><a name="line1518"></a>1518             end
</span><span class="uncovered1"><a name="line1519"></a>1519           end
</span><span class="uncovered0"><a name="line1520"></a>1520         end
</span><span class="uncovered1"><a name="line1521"></a>1521       end
</span><span class="uncovered0"><a name="line1522"></a>1522     end
</span><span class="inferred1"><a name="line1523"></a>1523 
</span><span class="inferred0"><a name="line1524"></a>1524     # Return a new file list that only contains file names from the current
</span><span class="inferred1"><a name="line1525"></a>1525     # file list that exist on the file system.
</span><span class="marked0"><a name="line1526"></a>1526     def existing
</span><span class="uncovered1"><a name="line1527"></a>1527       select { |fn| File.exist?(fn) }
</span><span class="uncovered0"><a name="line1528"></a>1528     end
</span><span class="inferred1"><a name="line1529"></a>1529 
</span><span class="inferred0"><a name="line1530"></a>1530     # Modify the current file list so that it contains only file name that
</span><span class="inferred1"><a name="line1531"></a>1531     # exist on the file system.
</span><span class="marked0"><a name="line1532"></a>1532     def existing!
</span><span class="uncovered1"><a name="line1533"></a>1533       resolve
</span><span class="uncovered0"><a name="line1534"></a>1534       @items = @items.select { |fn| File.exist?(fn) }
</span><span class="uncovered1"><a name="line1535"></a>1535       self
</span><span class="uncovered0"><a name="line1536"></a>1536     end
</span><span class="inferred1"><a name="line1537"></a>1537 
</span><span class="inferred0"><a name="line1538"></a>1538     # FileList version of partition.  Needed because the nested arrays should
</span><span class="inferred1"><a name="line1539"></a>1539     # be FileLists in this version.
</span><span class="marked0"><a name="line1540"></a>1540     def partition(&amp;block)       # :nodoc:
</span><span class="uncovered1"><a name="line1541"></a>1541       resolve
</span><span class="uncovered0"><a name="line1542"></a>1542       result = @items.partition(&amp;block)
</span><span class="uncovered1"><a name="line1543"></a>1543       [
</span><span class="uncovered0"><a name="line1544"></a>1544         FileList.new.import(result[0]),
</span><span class="uncovered1"><a name="line1545"></a>1545         FileList.new.import(result[1]),
</span><span class="uncovered0"><a name="line1546"></a>1546       ]
</span><span class="uncovered1"><a name="line1547"></a>1547     end
</span><span class="inferred0"><a name="line1548"></a>1548 
</span><span class="inferred1"><a name="line1549"></a>1549     # Convert a FileList to a string by joining all elements with a space.
</span><span class="marked0"><a name="line1550"></a>1550     def to_s
</span><span class="uncovered1"><a name="line1551"></a>1551       resolve
</span><span class="uncovered0"><a name="line1552"></a>1552       self.join(' ')
</span><span class="uncovered1"><a name="line1553"></a>1553     end
</span><span class="inferred0"><a name="line1554"></a>1554 
</span><span class="inferred1"><a name="line1555"></a>1555     # Add matching glob patterns.
</span><span class="marked0"><a name="line1556"></a>1556     def add_matching(pattern)
</span><span class="uncovered1"><a name="line1557"></a>1557       Dir[pattern].each do |fn|
</span><span class="uncovered0"><a name="line1558"></a>1558         self &lt;&lt; fn unless exclude?(fn)
</span><span class="uncovered1"><a name="line1559"></a>1559       end
</span><span class="uncovered0"><a name="line1560"></a>1560     end
</span><span class="marked1"><a name="line1561"></a>1561     private :add_matching
</span><span class="inferred0"><a name="line1562"></a>1562 
</span><span class="inferred1"><a name="line1563"></a>1563     # Should the given file name be excluded?
</span><span class="marked0"><a name="line1564"></a>1564     def exclude?(fn)
</span><span class="uncovered1"><a name="line1565"></a>1565       calculate_exclude_regexp unless @exclude_re
</span><span class="uncovered0"><a name="line1566"></a>1566       fn =~ @exclude_re || @exclude_procs.any? { |p| p.call(fn) }
</span><span class="uncovered1"><a name="line1567"></a>1567     end
</span><span class="inferred0"><a name="line1568"></a>1568 
</span><span class="marked1"><a name="line1569"></a>1569     DEFAULT_IGNORE_PATTERNS = [
</span><span class="inferred0"><a name="line1570"></a>1570       /(^|[\/\\])CVS([\/\\]|$)/,
</span><span class="inferred1"><a name="line1571"></a>1571       /(^|[\/\\])\.svn([\/\\]|$)/,
</span><span class="inferred0"><a name="line1572"></a>1572       /\.bak$/,
</span><span class="inferred1"><a name="line1573"></a>1573       /~$/
</span><span class="inferred0"><a name="line1574"></a>1574     ]
</span><span class="marked1"><a name="line1575"></a>1575     DEFAULT_IGNORE_PROCS = [
</span><span class="inferred0"><a name="line1576"></a>1576       proc { |fn| fn =~ /(^|[\/\\])core$/ &amp;&amp; ! File.directory?(fn) }
</span><span class="inferred1"><a name="line1577"></a>1577     ]
</span><span class="inferred0"><a name="line1578"></a>1578 #    @exclude_patterns = DEFAULT_IGNORE_PATTERNS.dup
</span><span class="inferred1"><a name="line1579"></a>1579 
</span><span class="marked0"><a name="line1580"></a>1580     def import(array)
</span><span class="uncovered1"><a name="line1581"></a>1581       @items = array
</span><span class="uncovered0"><a name="line1582"></a>1582       self
</span><span class="uncovered1"><a name="line1583"></a>1583     end
</span><span class="inferred0"><a name="line1584"></a>1584 
</span><span class="marked1"><a name="line1585"></a>1585     class &lt;&lt; self
</span><span class="inferred0"><a name="line1586"></a>1586       # Create a new file list including the files listed. Similar to:
</span><span class="inferred1"><a name="line1587"></a>1587       #
</span><span class="inferred0"><a name="line1588"></a>1588       #   FileList.new(*args)
</span><span class="marked1"><a name="line1589"></a>1589       def [](*args)
</span><span class="marked0"><a name="line1590"></a>1590         new(*args)
</span><span class="marked1"><a name="line1591"></a>1591       end
</span><span class="inferred0"><a name="line1592"></a>1592     end
</span><span class="inferred1"><a name="line1593"></a>1593   end # FileList
</span><span class="inferred0"><a name="line1594"></a>1594 end
</span><span class="inferred1"><a name="line1595"></a>1595 
</span><span class="marked0"><a name="line1596"></a>1596 module Rake
</span><span class="marked1"><a name="line1597"></a>1597   class &lt;&lt; self
</span><span class="inferred0"><a name="line1598"></a>1598 
</span><span class="inferred1"><a name="line1599"></a>1599     # Yield each file or directory component.
</span><span class="marked0"><a name="line1600"></a>1600     def each_dir_parent(dir)    # :nodoc:
</span><span class="uncovered1"><a name="line1601"></a>1601       old_length = nil
</span><span class="uncovered0"><a name="line1602"></a>1602       while dir != '.' &amp;&amp; dir.length != old_length
</span><span class="uncovered1"><a name="line1603"></a>1603         yield(dir)
</span><span class="uncovered0"><a name="line1604"></a>1604         old_length = dir.length
</span><span class="uncovered1"><a name="line1605"></a>1605         dir = File.dirname(dir)
</span><span class="uncovered0"><a name="line1606"></a>1606       end
</span><span class="uncovered1"><a name="line1607"></a>1607     end
</span><span class="uncovered0"><a name="line1608"></a>1608   end
</span><span class="uncovered1"><a name="line1609"></a>1609 end # module Rake
</span><span class="inferred0"><a name="line1610"></a>1610 
</span><span class="inferred1"><a name="line1611"></a>1611 # Alias FileList to be available at the top level.
</span><span class="marked0"><a name="line1612"></a>1612 FileList = Rake::FileList
</span><span class="inferred1"><a name="line1613"></a>1613 
</span><span class="inferred0"><a name="line1614"></a>1614 #############################################################################
</span><span class="marked1"><a name="line1615"></a>1615 module Rake
</span><span class="inferred0"><a name="line1616"></a>1616 
</span><span class="inferred1"><a name="line1617"></a>1617   # Default Rakefile loader used by +import+.
</span><span class="marked0"><a name="line1618"></a>1618   class DefaultLoader
</span><span class="marked1"><a name="line1619"></a>1619     def load(fn)
</span><span class="uncovered0"><a name="line1620"></a>1620       Kernel.load(File.expand_path(fn))
</span><span class="uncovered1"><a name="line1621"></a>1621     end
</span><span class="uncovered0"><a name="line1622"></a>1622   end
</span><span class="inferred1"><a name="line1623"></a>1623 
</span><span class="inferred0"><a name="line1624"></a>1624   # EarlyTime is a fake timestamp that occurs _before_ any other time value.
</span><span class="marked1"><a name="line1625"></a>1625   class EarlyTime
</span><span class="marked0"><a name="line1626"></a>1626     include Comparable
</span><span class="marked1"><a name="line1627"></a>1627     include Singleton
</span><span class="inferred0"><a name="line1628"></a>1628 
</span><span class="marked1"><a name="line1629"></a>1629     def &lt;=&gt;(other)
</span><span class="uncovered0"><a name="line1630"></a>1630       -1
</span><span class="uncovered1"><a name="line1631"></a>1631     end
</span><span class="inferred0"><a name="line1632"></a>1632 
</span><span class="marked1"><a name="line1633"></a>1633     def to_s
</span><span class="uncovered0"><a name="line1634"></a>1634       &quot;&lt;EARLY TIME&gt;&quot;
</span><span class="uncovered1"><a name="line1635"></a>1635     end
</span><span class="uncovered0"><a name="line1636"></a>1636   end
</span><span class="inferred1"><a name="line1637"></a>1637 
</span><span class="marked0"><a name="line1638"></a>1638   EARLY = EarlyTime.instance
</span><span class="inferred1"><a name="line1639"></a>1639 end # module Rake
</span><span class="inferred0"><a name="line1640"></a>1640 
</span><span class="inferred1"><a name="line1641"></a>1641 #############################################################################
</span><span class="inferred0"><a name="line1642"></a>1642 # Extensions to time to allow comparisons with an early time class.
</span><span class="inferred1"><a name="line1643"></a>1643 #
</span><span class="marked0"><a name="line1644"></a>1644 class Time
</span><span class="marked1"><a name="line1645"></a>1645   alias rake_original_time_compare :&lt;=&gt;
</span><span class="marked0"><a name="line1646"></a>1646   def &lt;=&gt;(other)
</span><span class="uncovered1"><a name="line1647"></a>1647     if Rake::EarlyTime === other
</span><span class="uncovered0"><a name="line1648"></a>1648       - other.&lt;=&gt;(self)
</span><span class="uncovered1"><a name="line1649"></a>1649     else
</span><span class="uncovered0"><a name="line1650"></a>1650       rake_original_time_compare(other)
</span><span class="uncovered1"><a name="line1651"></a>1651     end
</span><span class="uncovered0"><a name="line1652"></a>1652   end
</span><span class="uncovered1"><a name="line1653"></a>1653 end # class Time
</span><span class="inferred0"><a name="line1654"></a>1654 
</span><span class="marked1"><a name="line1655"></a>1655 module Rake
</span><span class="inferred0"><a name="line1656"></a>1656 
</span><span class="inferred1"><a name="line1657"></a>1657   ####################################################################
</span><span class="inferred0"><a name="line1658"></a>1658   # The NameSpace class will lookup task names in the the scope
</span><span class="inferred1"><a name="line1659"></a>1659   # defined by a +namespace+ command.
</span><span class="inferred0"><a name="line1660"></a>1660   #
</span><span class="marked1"><a name="line1661"></a>1661   class NameSpace
</span><span class="inferred0"><a name="line1662"></a>1662 
</span><span class="inferred1"><a name="line1663"></a>1663     # Create a namespace lookup object using the given task manager
</span><span class="inferred0"><a name="line1664"></a>1664     # and the list of scopes.
</span><span class="marked1"><a name="line1665"></a>1665     def initialize(task_manager, scope_list)
</span><span class="uncovered0"><a name="line1666"></a>1666       @task_manager = task_manager
</span><span class="uncovered1"><a name="line1667"></a>1667       @scope = scope_list.dup
</span><span class="uncovered0"><a name="line1668"></a>1668     end
</span><span class="inferred1"><a name="line1669"></a>1669 
</span><span class="inferred0"><a name="line1670"></a>1670     # Lookup a task named +name+ in the namespace.
</span><span class="marked1"><a name="line1671"></a>1671     def [](name)
</span><span class="uncovered0"><a name="line1672"></a>1672       @task_manager.lookup(name, @scope)
</span><span class="uncovered1"><a name="line1673"></a>1673     end
</span><span class="inferred0"><a name="line1674"></a>1674 
</span><span class="inferred1"><a name="line1675"></a>1675     # Return the list of tasks defined in this and nested namespaces.
</span><span class="marked0"><a name="line1676"></a>1676     def tasks
</span><span class="uncovered1"><a name="line1677"></a>1677       @task_manager.tasks_in_scope(@scope)
</span><span class="uncovered0"><a name="line1678"></a>1678     end
</span><span class="uncovered1"><a name="line1679"></a>1679   end # NameSpace
</span><span class="inferred0"><a name="line1680"></a>1680 
</span><span class="inferred1"><a name="line1681"></a>1681 
</span><span class="inferred0"><a name="line1682"></a>1682   ####################################################################
</span><span class="inferred1"><a name="line1683"></a>1683   # The TaskManager module is a mixin for managing tasks.
</span><span class="marked0"><a name="line1684"></a>1684   module TaskManager
</span><span class="inferred1"><a name="line1685"></a>1685     # Track the last comment made in the Rakefile.
</span><span class="marked0"><a name="line1686"></a>1686     attr_accessor :last_description
</span><span class="marked1"><a name="line1687"></a>1687     alias :last_comment :last_description    # Backwards compatibility
</span><span class="inferred0"><a name="line1688"></a>1688 
</span><span class="marked1"><a name="line1689"></a>1689     def initialize
</span><span class="marked0"><a name="line1690"></a>1690       super
</span><span class="marked1"><a name="line1691"></a>1691       @tasks = Hash.new
</span><span class="marked0"><a name="line1692"></a>1692       @rules = Array.new
</span><span class="marked1"><a name="line1693"></a>1693       @scope = Array.new
</span><span class="marked0"><a name="line1694"></a>1694       @last_description = nil
</span><span class="inferred1"><a name="line1695"></a>1695     end
</span><span class="inferred0"><a name="line1696"></a>1696 
</span><span class="marked1"><a name="line1697"></a>1697     def create_rule(*args, &amp;block)
</span><span class="uncovered0"><a name="line1698"></a>1698       pattern, arg_names, deps = resolve_args(args)
</span><span class="uncovered1"><a name="line1699"></a>1699       pattern = Regexp.new(Regexp.quote(pattern) + '$') if String === pattern
</span><span class="uncovered0"><a name="line1700"></a>1700       @rules &lt;&lt; [pattern, deps, block]
</span><span class="uncovered1"><a name="line1701"></a>1701     end
</span><span class="inferred0"><a name="line1702"></a>1702 
</span><span class="marked1"><a name="line1703"></a>1703     def define_task(task_class, *args, &amp;block)
</span><span class="marked0"><a name="line1704"></a>1704       task_name, arg_names, deps = resolve_args(args)
</span><span class="marked1"><a name="line1705"></a>1705       task_name = task_class.scope_name(@scope, task_name)
</span><span class="marked0"><a name="line1706"></a>1706       deps = [deps] unless deps.respond_to?(:to_ary)
</span><span class="marked1"><a name="line1707"></a>1707       deps = deps.collect {|d| d.to_s }
</span><span class="marked0"><a name="line1708"></a>1708       task = intern(task_class, task_name)
</span><span class="marked1"><a name="line1709"></a>1709       task.set_arg_names(arg_names) unless arg_names.empty?
</span><span class="marked0"><a name="line1710"></a>1710       task.add_description(@last_description)
</span><span class="marked1"><a name="line1711"></a>1711       @last_description = nil
</span><span class="marked0"><a name="line1712"></a>1712       task.enhance(deps, &amp;block)
</span><span class="marked1"><a name="line1713"></a>1713       task
</span><span class="inferred0"><a name="line1714"></a>1714     end
</span><span class="inferred1"><a name="line1715"></a>1715 
</span><span class="inferred0"><a name="line1716"></a>1716     # Lookup a task.  Return an existing task if found, otherwise
</span><span class="inferred1"><a name="line1717"></a>1717     # create a task of the current type.
</span><span class="marked0"><a name="line1718"></a>1718     def intern(task_class, task_name)
</span><span class="marked1"><a name="line1719"></a>1719       @tasks[task_name.to_s] ||= task_class.new(task_name, self)
</span><span class="marked0"><a name="line1720"></a>1720     end
</span><span class="inferred1"><a name="line1721"></a>1721 
</span><span class="inferred0"><a name="line1722"></a>1722     # Find a matching task for +task_name+.
</span><span class="marked1"><a name="line1723"></a>1723     def [](task_name, scopes=nil)
</span><span class="uncovered0"><a name="line1724"></a>1724       task_name = task_name.to_s
</span><span class="uncovered1"><a name="line1725"></a>1725       self.lookup(task_name, scopes) or
</span><span class="uncovered0"><a name="line1726"></a>1726         enhance_with_matching_rule(task_name) or
</span><span class="uncovered1"><a name="line1727"></a>1727         synthesize_file_task(task_name) or
</span><span class="uncovered0"><a name="line1728"></a>1728         fail &quot;Don't know how to build task '#{task_name}'&quot;
</span><span class="uncovered1"><a name="line1729"></a>1729     end
</span><span class="inferred0"><a name="line1730"></a>1730 
</span><span class="marked1"><a name="line1731"></a>1731     def synthesize_file_task(task_name)
</span><span class="uncovered0"><a name="line1732"></a>1732       return nil unless File.exist?(task_name)
</span><span class="uncovered1"><a name="line1733"></a>1733       define_task(Rake::FileTask, task_name)
</span><span class="uncovered0"><a name="line1734"></a>1734     end
</span><span class="inferred1"><a name="line1735"></a>1735 
</span><span class="inferred0"><a name="line1736"></a>1736     # Resolve the arguments for a task/rule.  Returns a triplet of
</span><span class="inferred1"><a name="line1737"></a>1737     # [task_name, arg_name_list, prerequisites].
</span><span class="marked0"><a name="line1738"></a>1738     def resolve_args(args)
</span><span class="marked1"><a name="line1739"></a>1739       if args.last.is_a?(Hash)
</span><span class="marked0"><a name="line1740"></a>1740         deps = args.pop
</span><span class="marked1"><a name="line1741"></a>1741         resolve_args_with_dependencies(args, deps)
</span><span class="inferred0"><a name="line1742"></a>1742       else
</span><span class="marked1"><a name="line1743"></a>1743         resolve_args_without_dependencies(args)
</span><span class="inferred0"><a name="line1744"></a>1744       end
</span><span class="marked1"><a name="line1745"></a>1745     end
</span><span class="inferred0"><a name="line1746"></a>1746 
</span><span class="inferred1"><a name="line1747"></a>1747     # Resolve task arguments for a task or rule when there are no
</span><span class="inferred0"><a name="line1748"></a>1748     # dependencies declared.
</span><span class="inferred1"><a name="line1749"></a>1749     #
</span><span class="inferred0"><a name="line1750"></a>1750     # The patterns recognized by this argument resolving function are:
</span><span class="inferred1"><a name="line1751"></a>1751     #
</span><span class="inferred0"><a name="line1752"></a>1752     #   task :t
</span><span class="inferred1"><a name="line1753"></a>1753     #   task :t, [:a]
</span><span class="inferred0"><a name="line1754"></a>1754     #   task :t, :a                 (deprecated)
</span><span class="inferred1"><a name="line1755"></a>1755     #
</span><span class="marked0"><a name="line1756"></a>1756     def resolve_args_without_dependencies(args)
</span><span class="marked1"><a name="line1757"></a>1757       task_name = args.shift
</span><span class="marked0"><a name="line1758"></a>1758       if args.size == 1 &amp;&amp; args.first.respond_to?(:to_ary)
</span><span class="uncovered1"><a name="line1759"></a>1759         arg_names = args.first.to_ary
</span><span class="inferred0"><a name="line1760"></a>1760       else
</span><span class="marked1"><a name="line1761"></a>1761         arg_names = args
</span><span class="inferred0"><a name="line1762"></a>1762       end
</span><span class="marked1"><a name="line1763"></a>1763       [task_name, arg_names, []]
</span><span class="inferred0"><a name="line1764"></a>1764     end
</span><span class="marked1"><a name="line1765"></a>1765     private :resolve_args_without_dependencies
</span><span class="inferred0"><a name="line1766"></a>1766     
</span><span class="inferred1"><a name="line1767"></a>1767     # Resolve task arguments for a task or rule when there are
</span><span class="inferred0"><a name="line1768"></a>1768     # dependencies declared.
</span><span class="inferred1"><a name="line1769"></a>1769     #
</span><span class="inferred0"><a name="line1770"></a>1770     # The patterns recognized by this argument resolving function are:
</span><span class="inferred1"><a name="line1771"></a>1771     #
</span><span class="inferred0"><a name="line1772"></a>1772     #   task :t =&gt; [:d]
</span><span class="inferred1"><a name="line1773"></a>1773     #   task :t, [a] =&gt; [:d]
</span><span class="inferred0"><a name="line1774"></a>1774     #   task :t, :needs =&gt; [:d]                 (deprecated)
</span><span class="inferred1"><a name="line1775"></a>1775     #   task :t, :a, :needs =&gt; [:d]             (deprecated)
</span><span class="inferred0"><a name="line1776"></a>1776     #
</span><span class="marked1"><a name="line1777"></a>1777     def resolve_args_with_dependencies(args, hash) # :nodoc:
</span><span class="marked0"><a name="line1778"></a>1778       fail &quot;Task Argument Error&quot; if hash.size != 1
</span><span class="marked1"><a name="line1779"></a>1779       key, value = hash.map { |k, v| [k,v] }.first
</span><span class="marked0"><a name="line1780"></a>1780       if args.empty?
</span><span class="marked1"><a name="line1781"></a>1781         task_name = key
</span><span class="marked0"><a name="line1782"></a>1782         arg_names = []
</span><span class="marked1"><a name="line1783"></a>1783         deps = value
</span><span class="uncovered0"><a name="line1784"></a>1784       elsif key == :needs
</span><span class="uncovered1"><a name="line1785"></a>1785         task_name = args.shift
</span><span class="uncovered0"><a name="line1786"></a>1786         arg_names = args
</span><span class="uncovered1"><a name="line1787"></a>1787         deps = value
</span><span class="uncovered0"><a name="line1788"></a>1788       else
</span><span class="uncovered1"><a name="line1789"></a>1789         task_name = args.shift
</span><span class="uncovered0"><a name="line1790"></a>1790         arg_names = key
</span><span class="uncovered1"><a name="line1791"></a>1791         deps = value
</span><span class="uncovered0"><a name="line1792"></a>1792       end
</span><span class="marked1"><a name="line1793"></a>1793       deps = [deps] unless deps.respond_to?(:to_ary)
</span><span class="marked0"><a name="line1794"></a>1794       [task_name, arg_names, deps]
</span><span class="inferred1"><a name="line1795"></a>1795     end
</span><span class="marked0"><a name="line1796"></a>1796     private :resolve_args_with_dependencies
</span><span class="inferred1"><a name="line1797"></a>1797     
</span><span class="inferred0"><a name="line1798"></a>1798     # If a rule can be found that matches the task name, enhance the
</span><span class="inferred1"><a name="line1799"></a>1799     # task with the prerequisites and actions from the rule.  Set the
</span><span class="inferred0"><a name="line1800"></a>1800     # source attribute of the task appropriately for the rule.  Return
</span><span class="inferred1"><a name="line1801"></a>1801     # the enhanced task or nil of no rule was found.
</span><span class="marked0"><a name="line1802"></a>1802     def enhance_with_matching_rule(task_name, level=0)
</span><span class="uncovered1"><a name="line1803"></a>1803       fail Rake::RuleRecursionOverflowError,
</span><span class="uncovered0"><a name="line1804"></a>1804         &quot;Rule Recursion Too Deep&quot; if level &gt;= 16
</span><span class="uncovered1"><a name="line1805"></a>1805       @rules.each do |pattern, extensions, block|
</span><span class="uncovered0"><a name="line1806"></a>1806         if md = pattern.match(task_name)
</span><span class="uncovered1"><a name="line1807"></a>1807           task = attempt_rule(task_name, extensions, block, level)
</span><span class="uncovered0"><a name="line1808"></a>1808           return task if task
</span><span class="uncovered1"><a name="line1809"></a>1809         end
</span><span class="uncovered0"><a name="line1810"></a>1810       end
</span><span class="uncovered1"><a name="line1811"></a>1811       nil
</span><span class="uncovered0"><a name="line1812"></a>1812     rescue Rake::RuleRecursionOverflowError =&gt; ex
</span><span class="uncovered1"><a name="line1813"></a>1813       ex.add_target(task_name)
</span><span class="uncovered0"><a name="line1814"></a>1814       fail ex
</span><span class="uncovered1"><a name="line1815"></a>1815     end
</span><span class="inferred0"><a name="line1816"></a>1816 
</span><span class="inferred1"><a name="line1817"></a>1817     # List of all defined tasks in this application.
</span><span class="marked0"><a name="line1818"></a>1818     def tasks
</span><span class="uncovered1"><a name="line1819"></a>1819       @tasks.values.sort_by { |t| t.name }
</span><span class="uncovered0"><a name="line1820"></a>1820     end
</span><span class="inferred1"><a name="line1821"></a>1821 
</span><span class="inferred0"><a name="line1822"></a>1822     # List of all the tasks defined in the given scope (and its
</span><span class="inferred1"><a name="line1823"></a>1823     # sub-scopes).
</span><span class="marked0"><a name="line1824"></a>1824     def tasks_in_scope(scope)
</span><span class="uncovered1"><a name="line1825"></a>1825       prefix = scope.join(&quot;:&quot;)
</span><span class="uncovered0"><a name="line1826"></a>1826       tasks.select { |t|
</span><span class="uncovered1"><a name="line1827"></a>1827         /^#{prefix}:/ =~ t.name
</span><span class="uncovered0"><a name="line1828"></a>1828       }
</span><span class="uncovered1"><a name="line1829"></a>1829     end
</span><span class="inferred0"><a name="line1830"></a>1830 
</span><span class="inferred1"><a name="line1831"></a>1831     # Clear all tasks in this application.
</span><span class="marked0"><a name="line1832"></a>1832     def clear
</span><span class="uncovered1"><a name="line1833"></a>1833       @tasks.clear
</span><span class="uncovered0"><a name="line1834"></a>1834       @rules.clear
</span><span class="uncovered1"><a name="line1835"></a>1835     end
</span><span class="inferred0"><a name="line1836"></a>1836 
</span><span class="inferred1"><a name="line1837"></a>1837     # Lookup a task, using scope and the scope hints in the task name.
</span><span class="inferred0"><a name="line1838"></a>1838     # This method performs straight lookups without trying to
</span><span class="inferred1"><a name="line1839"></a>1839     # synthesize file tasks or rules.  Special scope names (e.g. '^')
</span><span class="inferred0"><a name="line1840"></a>1840     # are recognized.  If no scope argument is supplied, use the
</span><span class="inferred1"><a name="line1841"></a>1841     # current scope.  Return nil if the task cannot be found.
</span><span class="marked0"><a name="line1842"></a>1842     def lookup(task_name, initial_scope=nil)
</span><span class="uncovered1"><a name="line1843"></a>1843       initial_scope ||= @scope
</span><span class="uncovered0"><a name="line1844"></a>1844       task_name = task_name.to_s
</span><span class="uncovered1"><a name="line1845"></a>1845       if task_name =~ /^rake:/
</span><span class="uncovered0"><a name="line1846"></a>1846         scopes = []
</span><span class="uncovered1"><a name="line1847"></a>1847         task_name = task_name.sub(/^rake:/, '')
</span><span class="uncovered0"><a name="line1848"></a>1848       elsif task_name =~ /^(\^+)/
</span><span class="uncovered1"><a name="line1849"></a>1849         scopes = initial_scope[0, initial_scope.size - $1.size]
</span><span class="uncovered0"><a name="line1850"></a>1850         task_name = task_name.sub(/^(\^+)/, '')
</span><span class="uncovered1"><a name="line1851"></a>1851       else
</span><span class="uncovered0"><a name="line1852"></a>1852         scopes = initial_scope
</span><span class="uncovered1"><a name="line1853"></a>1853       end
</span><span class="uncovered0"><a name="line1854"></a>1854       lookup_in_scope(task_name, scopes)
</span><span class="uncovered1"><a name="line1855"></a>1855     end
</span><span class="inferred0"><a name="line1856"></a>1856 
</span><span class="inferred1"><a name="line1857"></a>1857     # Lookup the task name
</span><span class="marked0"><a name="line1858"></a>1858     def lookup_in_scope(name, scope)
</span><span class="uncovered1"><a name="line1859"></a>1859       n = scope.size
</span><span class="uncovered0"><a name="line1860"></a>1860       while n &gt;= 0
</span><span class="uncovered1"><a name="line1861"></a>1861         tn = (scope[0,n] + [name]).join(':')
</span><span class="uncovered0"><a name="line1862"></a>1862         task = @tasks[tn]
</span><span class="uncovered1"><a name="line1863"></a>1863         return task if task
</span><span class="uncovered0"><a name="line1864"></a>1864         n -= 1
</span><span class="uncovered1"><a name="line1865"></a>1865       end
</span><span class="uncovered0"><a name="line1866"></a>1866       nil
</span><span class="uncovered1"><a name="line1867"></a>1867     end
</span><span class="marked0"><a name="line1868"></a>1868     private :lookup_in_scope
</span><span class="inferred1"><a name="line1869"></a>1869 
</span><span class="inferred0"><a name="line1870"></a>1870     # Return the list of scope names currently active in the task
</span><span class="inferred1"><a name="line1871"></a>1871     # manager.
</span><span class="marked0"><a name="line1872"></a>1872     def current_scope
</span><span class="marked1"><a name="line1873"></a>1873       @scope.dup
</span><span class="marked0"><a name="line1874"></a>1874     end
</span><span class="inferred1"><a name="line1875"></a>1875 
</span><span class="inferred0"><a name="line1876"></a>1876     # Evaluate the block in a nested namespace named +name+.  Create
</span><span class="inferred1"><a name="line1877"></a>1877     # an anonymous namespace if +name+ is nil.
</span><span class="marked0"><a name="line1878"></a>1878     def in_namespace(name)
</span><span class="uncovered1"><a name="line1879"></a>1879       name ||= generate_name
</span><span class="uncovered0"><a name="line1880"></a>1880       @scope.push(name)
</span><span class="uncovered1"><a name="line1881"></a>1881       ns = NameSpace.new(self, @scope)
</span><span class="uncovered0"><a name="line1882"></a>1882       yield(ns)
</span><span class="uncovered1"><a name="line1883"></a>1883       ns
</span><span class="uncovered0"><a name="line1884"></a>1884     ensure
</span><span class="uncovered1"><a name="line1885"></a>1885       @scope.pop
</span><span class="uncovered0"><a name="line1886"></a>1886     end
</span><span class="inferred1"><a name="line1887"></a>1887 
</span><span class="marked0"><a name="line1888"></a>1888     private
</span><span class="inferred1"><a name="line1889"></a>1889 
</span><span class="inferred0"><a name="line1890"></a>1890     # Generate an anonymous namespace name.
</span><span class="marked1"><a name="line1891"></a>1891     def generate_name
</span><span class="uncovered0"><a name="line1892"></a>1892       @seed ||= 0
</span><span class="uncovered1"><a name="line1893"></a>1893       @seed += 1
</span><span class="uncovered0"><a name="line1894"></a>1894       &quot;_anon_#{@seed}&quot;
</span><span class="uncovered1"><a name="line1895"></a>1895     end
</span><span class="inferred0"><a name="line1896"></a>1896 
</span><span class="marked1"><a name="line1897"></a>1897     def trace_rule(level, message)
</span><span class="uncovered0"><a name="line1898"></a>1898       puts &quot;#{&quot;    &quot;*level}#{message}&quot; if Rake.application.options.trace_rules
</span><span class="uncovered1"><a name="line1899"></a>1899     end
</span><span class="inferred0"><a name="line1900"></a>1900 
</span><span class="inferred1"><a name="line1901"></a>1901     # Attempt to create a rule given the list of prerequisites.
</span><span class="marked0"><a name="line1902"></a>1902     def attempt_rule(task_name, extensions, block, level)
</span><span class="uncovered1"><a name="line1903"></a>1903       sources = make_sources(task_name, extensions)
</span><span class="uncovered0"><a name="line1904"></a>1904       prereqs = sources.collect { |source|
</span><span class="uncovered1"><a name="line1905"></a>1905         trace_rule level, &quot;Attempting Rule #{task_name} =&gt; #{source}&quot;
</span><span class="uncovered0"><a name="line1906"></a>1906         if File.exist?(source) || Rake::Task.task_defined?(source)
</span><span class="uncovered1"><a name="line1907"></a>1907           trace_rule level, &quot;(#{task_name} =&gt; #{source} ... EXIST)&quot;
</span><span class="uncovered0"><a name="line1908"></a>1908           source
</span><span class="uncovered1"><a name="line1909"></a>1909         elsif parent = enhance_with_matching_rule(source, level+1)
</span><span class="uncovered0"><a name="line1910"></a>1910           trace_rule level, &quot;(#{task_name} =&gt; #{source} ... ENHANCE)&quot;
</span><span class="uncovered1"><a name="line1911"></a>1911           parent.name
</span><span class="uncovered0"><a name="line1912"></a>1912         else
</span><span class="uncovered1"><a name="line1913"></a>1913           trace_rule level, &quot;(#{task_name} =&gt; #{source} ... FAIL)&quot;
</span><span class="uncovered0"><a name="line1914"></a>1914           return nil
</span><span class="uncovered1"><a name="line1915"></a>1915         end
</span><span class="uncovered0"><a name="line1916"></a>1916       }
</span><span class="uncovered1"><a name="line1917"></a>1917       task = FileTask.define_task({task_name =&gt; prereqs}, &amp;block)
</span><span class="uncovered0"><a name="line1918"></a>1918       task.sources = prereqs
</span><span class="uncovered1"><a name="line1919"></a>1919       task
</span><span class="uncovered0"><a name="line1920"></a>1920     end
</span><span class="inferred1"><a name="line1921"></a>1921 
</span><span class="inferred0"><a name="line1922"></a>1922     # Make a list of sources from the list of file name extensions /
</span><span class="inferred1"><a name="line1923"></a>1923     # translation procs.
</span><span class="marked0"><a name="line1924"></a>1924     def make_sources(task_name, extensions)
</span><span class="uncovered1"><a name="line1925"></a>1925       extensions.collect { |ext|
</span><span class="uncovered0"><a name="line1926"></a>1926         case ext
</span><span class="uncovered1"><a name="line1927"></a>1927         when /%/
</span><span class="uncovered0"><a name="line1928"></a>1928           task_name.pathmap(ext)
</span><span class="uncovered1"><a name="line1929"></a>1929         when %r{/}
</span><span class="uncovered0"><a name="line1930"></a>1930           ext
</span><span class="uncovered1"><a name="line1931"></a>1931         when /^\./
</span><span class="uncovered0"><a name="line1932"></a>1932           task_name.ext(ext)
</span><span class="uncovered1"><a name="line1933"></a>1933         when String
</span><span class="uncovered0"><a name="line1934"></a>1934           ext
</span><span class="uncovered1"><a name="line1935"></a>1935         when Proc
</span><span class="uncovered0"><a name="line1936"></a>1936           if ext.arity == 1
</span><span class="uncovered1"><a name="line1937"></a>1937             ext.call(task_name)
</span><span class="uncovered0"><a name="line1938"></a>1938           else
</span><span class="uncovered1"><a name="line1939"></a>1939             ext.call
</span><span class="uncovered0"><a name="line1940"></a>1940           end
</span><span class="uncovered1"><a name="line1941"></a>1941         else
</span><span class="uncovered0"><a name="line1942"></a>1942           fail &quot;Don't know how to handle rule dependent: #{ext.inspect}&quot;
</span><span class="uncovered1"><a name="line1943"></a>1943         end
</span><span class="uncovered0"><a name="line1944"></a>1944       }.flatten
</span><span class="uncovered1"><a name="line1945"></a>1945     end
</span><span class="uncovered0"><a name="line1946"></a>1946 
</span><span class="uncovered1"><a name="line1947"></a>1947   end # TaskManager
</span><span class="inferred0"><a name="line1948"></a>1948 
</span><span class="inferred1"><a name="line1949"></a>1949   ######################################################################
</span><span class="inferred0"><a name="line1950"></a>1950   # Rake main application object.  When invoking +rake+ from the
</span><span class="inferred1"><a name="line1951"></a>1951   # command line, a Rake::Application object is created and run.
</span><span class="inferred0"><a name="line1952"></a>1952   #
</span><span class="marked1"><a name="line1953"></a>1953   class Application
</span><span class="marked0"><a name="line1954"></a>1954     include TaskManager
</span><span class="inferred1"><a name="line1955"></a>1955 
</span><span class="inferred0"><a name="line1956"></a>1956     # The name of the application (typically 'rake')
</span><span class="marked1"><a name="line1957"></a>1957     attr_reader :name
</span><span class="inferred0"><a name="line1958"></a>1958 
</span><span class="inferred1"><a name="line1959"></a>1959     # The original directory where rake was invoked.
</span><span class="marked0"><a name="line1960"></a>1960     attr_reader :original_dir
</span><span class="inferred1"><a name="line1961"></a>1961 
</span><span class="inferred0"><a name="line1962"></a>1962     # Name of the actual rakefile used.
</span><span class="marked1"><a name="line1963"></a>1963     attr_reader :rakefile
</span><span class="inferred0"><a name="line1964"></a>1964 
</span><span class="inferred1"><a name="line1965"></a>1965     # List of the top level task names (task names from the command line).
</span><span class="marked0"><a name="line1966"></a>1966     attr_reader :top_level_tasks
</span><span class="inferred1"><a name="line1967"></a>1967 
</span><span class="marked0"><a name="line1968"></a>1968     DEFAULT_RAKEFILES = ['rakefile', 'Rakefile', 'rakefile.rb', 'Rakefile.rb'].freeze
</span><span class="inferred1"><a name="line1969"></a>1969 
</span><span class="inferred0"><a name="line1970"></a>1970     # Initialize a Rake::Application object.
</span><span class="marked1"><a name="line1971"></a>1971     def initialize
</span><span class="marked0"><a name="line1972"></a>1972       super
</span><span class="marked1"><a name="line1973"></a>1973       @name = 'rake'
</span><span class="marked0"><a name="line1974"></a>1974       @rakefiles = DEFAULT_RAKEFILES.dup
</span><span class="marked1"><a name="line1975"></a>1975       @rakefile = nil
</span><span class="marked0"><a name="line1976"></a>1976       @pending_imports = []
</span><span class="marked1"><a name="line1977"></a>1977       @imported = []
</span><span class="marked0"><a name="line1978"></a>1978       @loaders = {}
</span><span class="marked1"><a name="line1979"></a>1979       @default_loader = Rake::DefaultLoader.new
</span><span class="marked0"><a name="line1980"></a>1980       @original_dir = Dir.pwd
</span><span class="marked1"><a name="line1981"></a>1981       @top_level_tasks = []
</span><span class="marked0"><a name="line1982"></a>1982       add_loader('rb', DefaultLoader.new)
</span><span class="marked1"><a name="line1983"></a>1983       add_loader('rf', DefaultLoader.new)
</span><span class="marked0"><a name="line1984"></a>1984       add_loader('rake', DefaultLoader.new)
</span><span class="marked1"><a name="line1985"></a>1985       @tty_output = STDOUT.tty?
</span><span class="inferred0"><a name="line1986"></a>1986     end
</span><span class="inferred1"><a name="line1987"></a>1987 
</span><span class="inferred0"><a name="line1988"></a>1988     # Run the Rake application.  The run method performs the following three steps:
</span><span class="inferred1"><a name="line1989"></a>1989     #
</span><span class="inferred0"><a name="line1990"></a>1990     # * Initialize the command line options (+init+).
</span><span class="inferred1"><a name="line1991"></a>1991     # * Define the tasks (+load_rakefile+).
</span><span class="inferred0"><a name="line1992"></a>1992     # * Run the top level tasks (+run_tasks+).
</span><span class="inferred1"><a name="line1993"></a>1993     #
</span><span class="inferred0"><a name="line1994"></a>1994     # If you wish to build a custom rake command, you should call +init+ on your
</span><span class="inferred1"><a name="line1995"></a>1995     # application.  The define any tasks.  Finally, call +top_level+ to run your top
</span><span class="inferred0"><a name="line1996"></a>1996     # level tasks.
</span><span class="marked1"><a name="line1997"></a>1997     def run
</span><span class="uncovered0"><a name="line1998"></a>1998       standard_exception_handling do
</span><span class="uncovered1"><a name="line1999"></a>1999         init
</span><span class="uncovered0"><a name="line2000"></a>2000         load_rakefile
</span><span class="uncovered1"><a name="line2001"></a>2001         top_level
</span><span class="uncovered0"><a name="line2002"></a>2002       end
</span><span class="uncovered1"><a name="line2003"></a>2003     end
</span><span class="inferred0"><a name="line2004"></a>2004 
</span><span class="inferred1"><a name="line2005"></a>2005     # Initialize the command line parameters and app name.
</span><span class="marked0"><a name="line2006"></a>2006     def init(app_name='rake')
</span><span class="uncovered1"><a name="line2007"></a>2007       standard_exception_handling do
</span><span class="uncovered0"><a name="line2008"></a>2008         @name = app_name
</span><span class="uncovered1"><a name="line2009"></a>2009         handle_options
</span><span class="uncovered0"><a name="line2010"></a>2010         collect_tasks
</span><span class="uncovered1"><a name="line2011"></a>2011       end
</span><span class="uncovered0"><a name="line2012"></a>2012     end
</span><span class="inferred1"><a name="line2013"></a>2013 
</span><span class="inferred0"><a name="line2014"></a>2014     # Find the rakefile and then load it and any pending imports.
</span><span class="marked1"><a name="line2015"></a>2015     def load_rakefile
</span><span class="uncovered0"><a name="line2016"></a>2016       standard_exception_handling do
</span><span class="uncovered1"><a name="line2017"></a>2017         raw_load_rakefile
</span><span class="uncovered0"><a name="line2018"></a>2018       end
</span><span class="uncovered1"><a name="line2019"></a>2019     end
</span><span class="inferred0"><a name="line2020"></a>2020 
</span><span class="inferred1"><a name="line2021"></a>2021     # Run the top level tasks of a Rake application.
</span><span class="marked0"><a name="line2022"></a>2022     def top_level
</span><span class="uncovered1"><a name="line2023"></a>2023       standard_exception_handling do
</span><span class="uncovered0"><a name="line2024"></a>2024         if options.show_tasks
</span><span class="uncovered1"><a name="line2025"></a>2025           display_tasks_and_comments
</span><span class="uncovered0"><a name="line2026"></a>2026         elsif options.show_prereqs
</span><span class="uncovered1"><a name="line2027"></a>2027           display_prerequisites
</span><span class="uncovered0"><a name="line2028"></a>2028         else
</span><span class="uncovered1"><a name="line2029"></a>2029           top_level_tasks.each { |task_name| invoke_task(task_name) }
</span><span class="uncovered0"><a name="line2030"></a>2030         end
</span><span class="uncovered1"><a name="line2031"></a>2031       end
</span><span class="uncovered0"><a name="line2032"></a>2032     end
</span><span class="inferred1"><a name="line2033"></a>2033 
</span><span class="inferred0"><a name="line2034"></a>2034     # Add a loader to handle imported files ending in the extension
</span><span class="inferred1"><a name="line2035"></a>2035     # +ext+.
</span><span class="marked0"><a name="line2036"></a>2036     def add_loader(ext, loader)
</span><span class="marked1"><a name="line2037"></a>2037       ext = &quot;.#{ext}&quot; unless ext =~ /^\./
</span><span class="marked0"><a name="line2038"></a>2038       @loaders[ext] = loader
</span><span class="inferred1"><a name="line2039"></a>2039     end
</span><span class="inferred0"><a name="line2040"></a>2040 
</span><span class="inferred1"><a name="line2041"></a>2041     # Application options from the command line
</span><span class="marked0"><a name="line2042"></a>2042     def options
</span><span class="uncovered1"><a name="line2043"></a>2043       @options ||= OpenStruct.new
</span><span class="uncovered0"><a name="line2044"></a>2044     end
</span><span class="inferred1"><a name="line2045"></a>2045 
</span><span class="inferred0"><a name="line2046"></a>2046     # private ----------------------------------------------------------------
</span><span class="inferred1"><a name="line2047"></a>2047 
</span><span class="marked0"><a name="line2048"></a>2048     def invoke_task(task_string)
</span><span class="uncovered1"><a name="line2049"></a>2049       name, args = parse_task_string(task_string)
</span><span class="uncovered0"><a name="line2050"></a>2050       t = self[name]
</span><span class="uncovered1"><a name="line2051"></a>2051       t.invoke(*args)
</span><span class="uncovered0"><a name="line2052"></a>2052     end
</span><span class="inferred1"><a name="line2053"></a>2053 
</span><span class="marked0"><a name="line2054"></a>2054     def parse_task_string(string)
</span><span class="uncovered1"><a name="line2055"></a>2055       if string =~ /^([^\[]+)(\[(.*)\])$/
</span><span class="uncovered0"><a name="line2056"></a>2056         name = $1
</span><span class="uncovered1"><a name="line2057"></a>2057         args = $3.split(/\s*,\s*/)
</span><span class="uncovered0"><a name="line2058"></a>2058       else
</span><span class="uncovered1"><a name="line2059"></a>2059         name = string
</span><span class="uncovered0"><a name="line2060"></a>2060         args = []
</span><span class="uncovered1"><a name="line2061"></a>2061       end
</span><span class="uncovered0"><a name="line2062"></a>2062       [name, args]
</span><span class="uncovered1"><a name="line2063"></a>2063     end
</span><span class="inferred0"><a name="line2064"></a>2064 
</span><span class="inferred1"><a name="line2065"></a>2065     # Provide standard execption handling for the given block.
</span><span class="marked0"><a name="line2066"></a>2066     def standard_exception_handling
</span><span class="uncovered1"><a name="line2067"></a>2067       begin
</span><span class="uncovered0"><a name="line2068"></a>2068         yield
</span><span class="uncovered1"><a name="line2069"></a>2069       rescue SystemExit =&gt; ex
</span><span class="uncovered0"><a name="line2070"></a>2070         # Exit silently with current status
</span><span class="uncovered1"><a name="line2071"></a>2071         raise
</span><span class="uncovered0"><a name="line2072"></a>2072       rescue OptionParser::InvalidOption =&gt; ex
</span><span class="uncovered1"><a name="line2073"></a>2073         # Exit silently
</span><span class="uncovered0"><a name="line2074"></a>2074         exit(false)
</span><span class="uncovered1"><a name="line2075"></a>2075       rescue Exception =&gt; ex
</span><span class="uncovered0"><a name="line2076"></a>2076         # Exit with error message
</span><span class="uncovered1"><a name="line2077"></a>2077         $stderr.puts &quot;#{name} aborted!&quot;
</span><span class="uncovered0"><a name="line2078"></a>2078         $stderr.puts ex.message
</span><span class="uncovered1"><a name="line2079"></a>2079         if options.trace
</span><span class="uncovered0"><a name="line2080"></a>2080           $stderr.puts ex.backtrace.join(&quot;\n&quot;)
</span><span class="uncovered1"><a name="line2081"></a>2081         else
</span><span class="uncovered0"><a name="line2082"></a>2082           $stderr.puts ex.backtrace.find {|str| str =~ /#{@rakefile}/ } || &quot;&quot;
</span><span class="uncovered1"><a name="line2083"></a>2083           $stderr.puts &quot;(See full trace by running task with --trace)&quot;
</span><span class="uncovered0"><a name="line2084"></a>2084         end
</span><span class="uncovered1"><a name="line2085"></a>2085         exit(false)
</span><span class="uncovered0"><a name="line2086"></a>2086       end
</span><span class="uncovered1"><a name="line2087"></a>2087     end
</span><span class="inferred0"><a name="line2088"></a>2088 
</span><span class="inferred1"><a name="line2089"></a>2089     # True if one of the files in RAKEFILES is in the current directory.
</span><span class="inferred0"><a name="line2090"></a>2090     # If a match is found, it is copied into @rakefile.
</span><span class="marked1"><a name="line2091"></a>2091     def have_rakefile
</span><span class="uncovered0"><a name="line2092"></a>2092       @rakefiles.each do |fn|
</span><span class="uncovered1"><a name="line2093"></a>2093         if File.exist?(fn)
</span><span class="uncovered0"><a name="line2094"></a>2094           others = Dir.glob(fn, File::FNM_CASEFOLD)
</span><span class="uncovered1"><a name="line2095"></a>2095           return others.size == 1 ? others.first : fn
</span><span class="uncovered0"><a name="line2096"></a>2096         elsif fn == ''
</span><span class="uncovered1"><a name="line2097"></a>2097           return fn
</span><span class="uncovered0"><a name="line2098"></a>2098         end
</span><span class="uncovered1"><a name="line2099"></a>2099       end
</span><span class="uncovered0"><a name="line2100"></a>2100       return nil
</span><span class="uncovered1"><a name="line2101"></a>2101     end
</span><span class="inferred0"><a name="line2102"></a>2102 
</span><span class="inferred1"><a name="line2103"></a>2103     # True if we are outputting to TTY, false otherwise
</span><span class="marked0"><a name="line2104"></a>2104     def tty_output?
</span><span class="uncovered1"><a name="line2105"></a>2105       @tty_output
</span><span class="uncovered0"><a name="line2106"></a>2106     end
</span><span class="inferred1"><a name="line2107"></a>2107 
</span><span class="inferred0"><a name="line2108"></a>2108     # Override the detected TTY output state (mostly for testing)
</span><span class="marked1"><a name="line2109"></a>2109     def tty_output=( tty_output_state )
</span><span class="uncovered0"><a name="line2110"></a>2110       @tty_output = tty_output_state
</span><span class="uncovered1"><a name="line2111"></a>2111     end
</span><span class="inferred0"><a name="line2112"></a>2112 
</span><span class="inferred1"><a name="line2113"></a>2113     # We will truncate output if we are outputting to a TTY or if we've been
</span><span class="inferred0"><a name="line2114"></a>2114     # given an explicit column width to honor
</span><span class="marked1"><a name="line2115"></a>2115     def truncate_output?
</span><span class="uncovered0"><a name="line2116"></a>2116       tty_output? || ENV['RAKE_COLUMNS']
</span><span class="uncovered1"><a name="line2117"></a>2117     end
</span><span class="inferred0"><a name="line2118"></a>2118 
</span><span class="inferred1"><a name="line2119"></a>2119     # Display the tasks and comments.
</span><span class="marked0"><a name="line2120"></a>2120     def display_tasks_and_comments
</span><span class="uncovered1"><a name="line2121"></a>2121       displayable_tasks = tasks.select { |t|
</span><span class="uncovered0"><a name="line2122"></a>2122         t.comment &amp;&amp; t.name =~ options.show_task_pattern
</span><span class="uncovered1"><a name="line2123"></a>2123       }
</span><span class="uncovered0"><a name="line2124"></a>2124       if options.full_description
</span><span class="uncovered1"><a name="line2125"></a>2125         displayable_tasks.each do |t|
</span><span class="uncovered0"><a name="line2126"></a>2126           puts &quot;#{name} #{t.name_with_args}&quot;
</span><span class="uncovered1"><a name="line2127"></a>2127           t.full_comment.split(&quot;\n&quot;).each do |line|
</span><span class="uncovered0"><a name="line2128"></a>2128             puts &quot;    #{line}&quot;
</span><span class="uncovered1"><a name="line2129"></a>2129           end
</span><span class="uncovered0"><a name="line2130"></a>2130           puts
</span><span class="uncovered1"><a name="line2131"></a>2131         end
</span><span class="uncovered0"><a name="line2132"></a>2132       else
</span><span class="uncovered1"><a name="line2133"></a>2133         width = displayable_tasks.collect { |t| t.name_with_args.length }.max || 10
</span><span class="uncovered0"><a name="line2134"></a>2134         max_column = truncate_output? ? terminal_width - name.size - width - 7 : nil
</span><span class="uncovered1"><a name="line2135"></a>2135         displayable_tasks.each do |t|
</span><span class="uncovered0"><a name="line2136"></a>2136           printf &quot;#{name} %-#{width}s  # %s\n&quot;,
</span><span class="uncovered1"><a name="line2137"></a>2137             t.name_with_args, max_column ? truncate(t.comment, max_column) : t.comment
</span><span class="uncovered0"><a name="line2138"></a>2138         end
</span><span class="uncovered1"><a name="line2139"></a>2139       end
</span><span class="uncovered0"><a name="line2140"></a>2140     end
</span><span class="inferred1"><a name="line2141"></a>2141 
</span><span class="marked0"><a name="line2142"></a>2142     def terminal_width
</span><span class="uncovered1"><a name="line2143"></a>2143       if ENV['RAKE_COLUMNS']
</span><span class="uncovered0"><a name="line2144"></a>2144         result = ENV['RAKE_COLUMNS'].to_i
</span><span class="uncovered1"><a name="line2145"></a>2145       else
</span><span class="uncovered0"><a name="line2146"></a>2146         result = unix? ? dynamic_width : 80
</span><span class="uncovered1"><a name="line2147"></a>2147       end
</span><span class="uncovered0"><a name="line2148"></a>2148       (result &lt; 10) ? 80 : result
</span><span class="uncovered1"><a name="line2149"></a>2149     rescue
</span><span class="uncovered0"><a name="line2150"></a>2150       80
</span><span class="uncovered1"><a name="line2151"></a>2151     end
</span><span class="inferred0"><a name="line2152"></a>2152 
</span><span class="inferred1"><a name="line2153"></a>2153     # Calculate the dynamic width of the 
</span><span class="marked0"><a name="line2154"></a>2154     def dynamic_width
</span><span class="uncovered1"><a name="line2155"></a>2155       @dynamic_width ||= (dynamic_width_stty.nonzero? || dynamic_width_tput)
</span><span class="uncovered0"><a name="line2156"></a>2156     end
</span><span class="inferred1"><a name="line2157"></a>2157 
</span><span class="marked0"><a name="line2158"></a>2158     def dynamic_width_stty
</span><span class="inferred1"><a name="line2159"></a>2159       %x{stty size 2&gt;/dev/null}.split[1].to_i
</span><span class="inferred0"><a name="line2160"></a>2160     end
</span><span class="inferred1"><a name="line2161"></a>2161 
</span><span class="marked0"><a name="line2162"></a>2162     def dynamic_width_tput
</span><span class="inferred1"><a name="line2163"></a>2163       %x{tput cols 2&gt;/dev/null}.to_i
</span><span class="inferred0"><a name="line2164"></a>2164     end
</span><span class="inferred1"><a name="line2165"></a>2165 
</span><span class="marked0"><a name="line2166"></a>2166     def unix?
</span><span class="uncovered1"><a name="line2167"></a>2167       RUBY_PLATFORM =~ /(aix|darwin|linux|(net|free|open)bsd|cygwin|solaris|irix|hpux)/i
</span><span class="uncovered0"><a name="line2168"></a>2168     end
</span><span class="inferred1"><a name="line2169"></a>2169     
</span><span class="marked0"><a name="line2170"></a>2170     def windows?
</span><span class="uncovered1"><a name="line2171"></a>2171       Win32.windows?
</span><span class="uncovered0"><a name="line2172"></a>2172     end
</span><span class="inferred1"><a name="line2173"></a>2173 
</span><span class="marked0"><a name="line2174"></a>2174     def truncate(string, width)
</span><span class="uncovered1"><a name="line2175"></a>2175       if string.length &lt;= width
</span><span class="uncovered0"><a name="line2176"></a>2176         string
</span><span class="uncovered1"><a name="line2177"></a>2177       else
</span><span class="uncovered0"><a name="line2178"></a>2178         ( string[0, width-3] || &quot;&quot; ) + &quot;...&quot;
</span><span class="uncovered1"><a name="line2179"></a>2179       end
</span><span class="uncovered0"><a name="line2180"></a>2180     end
</span><span class="inferred1"><a name="line2181"></a>2181 
</span><span class="inferred0"><a name="line2182"></a>2182     # Display the tasks and prerequisites
</span><span class="marked1"><a name="line2183"></a>2183     def display_prerequisites
</span><span class="uncovered0"><a name="line2184"></a>2184       tasks.each do |t|
</span><span class="uncovered1"><a name="line2185"></a>2185         puts &quot;#{name} #{t.name}&quot;
</span><span class="uncovered0"><a name="line2186"></a>2186         t.prerequisites.each { |pre| puts &quot;    #{pre}&quot; }
</span><span class="uncovered1"><a name="line2187"></a>2187       end
</span><span class="uncovered0"><a name="line2188"></a>2188     end
</span><span class="inferred1"><a name="line2189"></a>2189 
</span><span class="inferred0"><a name="line2190"></a>2190     # A list of all the standard options used in rake, suitable for
</span><span class="inferred1"><a name="line2191"></a>2191     # passing to OptionParser.
</span><span class="marked0"><a name="line2192"></a>2192     def standard_rake_options
</span><span class="uncovered1"><a name="line2193"></a>2193       [
</span><span class="uncovered0"><a name="line2194"></a>2194         ['--classic-namespace', '-C', &quot;Put Task and FileTask in the top level namespace&quot;,
</span><span class="uncovered1"><a name="line2195"></a>2195           lambda { |value|
</span><span class="uncovered0"><a name="line2196"></a>2196             require 'rake/classic_namespace'
</span><span class="uncovered1"><a name="line2197"></a>2197             options.classic_namespace = true
</span><span class="uncovered0"><a name="line2198"></a>2198           }
</span><span class="uncovered1"><a name="line2199"></a>2199         ],
</span><span class="uncovered0"><a name="line2200"></a>2200         ['--describe', '-D [PATTERN]', &quot;Describe the tasks (matching optional PATTERN), then exit.&quot;,
</span><span class="uncovered1"><a name="line2201"></a>2201           lambda { |value|
</span><span class="uncovered0"><a name="line2202"></a>2202             options.show_tasks = true
</span><span class="uncovered1"><a name="line2203"></a>2203             options.full_description = true
</span><span class="uncovered0"><a name="line2204"></a>2204             options.show_task_pattern = Regexp.new(value || '')
</span><span class="uncovered1"><a name="line2205"></a>2205           }
</span><span class="uncovered0"><a name="line2206"></a>2206         ],
</span><span class="uncovered1"><a name="line2207"></a>2207         ['--dry-run', '-n', &quot;Do a dry run without executing actions.&quot;,
</span><span class="uncovered0"><a name="line2208"></a>2208           lambda { |value|
</span><span class="uncovered1"><a name="line2209"></a>2209             verbose(true)
</span><span class="uncovered0"><a name="line2210"></a>2210             nowrite(true)
</span><span class="uncovered1"><a name="line2211"></a>2211             options.dryrun = true
</span><span class="uncovered0"><a name="line2212"></a>2212             options.trace = true
</span><span class="uncovered1"><a name="line2213"></a>2213           }
</span><span class="uncovered0"><a name="line2214"></a>2214         ],
</span><span class="uncovered1"><a name="line2215"></a>2215         ['--execute',  '-e CODE', &quot;Execute some Ruby code and exit.&quot;,
</span><span class="uncovered0"><a name="line2216"></a>2216           lambda { |value|
</span><span class="uncovered1"><a name="line2217"></a>2217             eval(value)
</span><span class="uncovered0"><a name="line2218"></a>2218             exit
</span><span class="uncovered1"><a name="line2219"></a>2219           }
</span><span class="uncovered0"><a name="line2220"></a>2220         ],
</span><span class="uncovered1"><a name="line2221"></a>2221         ['--execute-print',  '-p CODE', &quot;Execute some Ruby code, print the result, then exit.&quot;,
</span><span class="uncovered0"><a name="line2222"></a>2222           lambda { |value|
</span><span class="uncovered1"><a name="line2223"></a>2223             puts eval(value)
</span><span class="uncovered0"><a name="line2224"></a>2224             exit
</span><span class="uncovered1"><a name="line2225"></a>2225           }
</span><span class="uncovered0"><a name="line2226"></a>2226         ],
</span><span class="uncovered1"><a name="line2227"></a>2227         ['--execute-continue',  '-E CODE',
</span><span class="uncovered0"><a name="line2228"></a>2228           &quot;Execute some Ruby code, then continue with normal task processing.&quot;,
</span><span class="uncovered1"><a name="line2229"></a>2229           lambda { |value| eval(value) }            
</span><span class="uncovered0"><a name="line2230"></a>2230         ],
</span><span class="uncovered1"><a name="line2231"></a>2231         ['--libdir', '-I LIBDIR', &quot;Include LIBDIR in the search path for required modules.&quot;,
</span><span class="uncovered0"><a name="line2232"></a>2232           lambda { |value| $:.push(value) }
</span><span class="uncovered1"><a name="line2233"></a>2233         ],
</span><span class="uncovered0"><a name="line2234"></a>2234         ['--prereqs', '-P', &quot;Display the tasks and dependencies, then exit.&quot;,
</span><span class="uncovered1"><a name="line2235"></a>2235           lambda { |value| options.show_prereqs = true }
</span><span class="uncovered0"><a name="line2236"></a>2236         ],
</span><span class="uncovered1"><a name="line2237"></a>2237         ['--quiet', '-q', &quot;Do not log messages to standard output.&quot;,
</span><span class="uncovered0"><a name="line2238"></a>2238           lambda { |value| verbose(false) }
</span><span class="uncovered1"><a name="line2239"></a>2239         ],
</span><span class="uncovered0"><a name="line2240"></a>2240         ['--rakefile', '-f [FILE]', &quot;Use FILE as the rakefile.&quot;,
</span><span class="uncovered1"><a name="line2241"></a>2241           lambda { |value| 
</span><span class="uncovered0"><a name="line2242"></a>2242             value ||= ''
</span><span class="uncovered1"><a name="line2243"></a>2243             @rakefiles.clear 
</span><span class="uncovered0"><a name="line2244"></a>2244             @rakefiles &lt;&lt; value
</span><span class="uncovered1"><a name="line2245"></a>2245           }
</span><span class="uncovered0"><a name="line2246"></a>2246         ],
</span><span class="uncovered1"><a name="line2247"></a>2247         ['--rakelibdir', '--rakelib', '-R RAKELIBDIR',
</span><span class="uncovered0"><a name="line2248"></a>2248           &quot;Auto-import any .rake files in RAKELIBDIR. (default is 'rakelib')&quot;,
</span><span class="uncovered1"><a name="line2249"></a>2249           lambda { |value| options.rakelib = value.split(':') }
</span><span class="uncovered0"><a name="line2250"></a>2250         ],
</span><span class="uncovered1"><a name="line2251"></a>2251         ['--require', '-r MODULE', &quot;Require MODULE before executing rakefile.&quot;,
</span><span class="uncovered0"><a name="line2252"></a>2252           lambda { |value|
</span><span class="uncovered1"><a name="line2253"></a>2253             begin
</span><span class="uncovered0"><a name="line2254"></a>2254               require value
</span><span class="uncovered1"><a name="line2255"></a>2255             rescue LoadError =&gt; ex
</span><span class="uncovered0"><a name="line2256"></a>2256               begin
</span><span class="uncovered1"><a name="line2257"></a>2257                 rake_require value
</span><span class="uncovered0"><a name="line2258"></a>2258               rescue LoadError =&gt; ex2
</span><span class="uncovered1"><a name="line2259"></a>2259                 raise ex
</span><span class="uncovered0"><a name="line2260"></a>2260               end
</span><span class="uncovered1"><a name="line2261"></a>2261             end
</span><span class="uncovered0"><a name="line2262"></a>2262           }
</span><span class="uncovered1"><a name="line2263"></a>2263         ],
</span><span class="uncovered0"><a name="line2264"></a>2264         ['--rules', &quot;Trace the rules resolution.&quot;,
</span><span class="uncovered1"><a name="line2265"></a>2265           lambda { |value| options.trace_rules = true }
</span><span class="uncovered0"><a name="line2266"></a>2266         ],
</span><span class="uncovered1"><a name="line2267"></a>2267         ['--no-search', '--nosearch', '-N', &quot;Do not search parent directories for the Rakefile.&quot;,
</span><span class="uncovered0"><a name="line2268"></a>2268           lambda { |value| options.nosearch = true }
</span><span class="uncovered1"><a name="line2269"></a>2269         ],
</span><span class="uncovered0"><a name="line2270"></a>2270         ['--silent', '-s', &quot;Like --quiet, but also suppresses the 'in directory' announcement.&quot;,
</span><span class="uncovered1"><a name="line2271"></a>2271           lambda { |value|
</span><span class="uncovered0"><a name="line2272"></a>2272             verbose(false)
</span><span class="uncovered1"><a name="line2273"></a>2273             options.silent = true
</span><span class="uncovered0"><a name="line2274"></a>2274           }
</span><span class="uncovered1"><a name="line2275"></a>2275         ],
</span><span class="uncovered0"><a name="line2276"></a>2276         ['--system',  '-g',
</span><span class="uncovered1"><a name="line2277"></a>2277           &quot;Using system wide (global) rakefiles (usually '~/.rake/*.rake').&quot;,
</span><span class="uncovered0"><a name="line2278"></a>2278           lambda { |value| options.load_system = true }
</span><span class="uncovered1"><a name="line2279"></a>2279         ],
</span><span class="uncovered0"><a name="line2280"></a>2280         ['--no-system', '--nosystem', '-G',
</span><span class="uncovered1"><a name="line2281"></a>2281           &quot;Use standard project Rakefile search paths, ignore system wide rakefiles.&quot;,
</span><span class="uncovered0"><a name="line2282"></a>2282           lambda { |value| options.ignore_system = true }
</span><span class="uncovered1"><a name="line2283"></a>2283         ],
</span><span class="uncovered0"><a name="line2284"></a>2284         ['--tasks', '-T [PATTERN]', &quot;Display the tasks (matching optional PATTERN) with descriptions, then exit.&quot;,
</span><span class="uncovered1"><a name="line2285"></a>2285           lambda { |value|
</span><span class="uncovered0"><a name="line2286"></a>2286             options.show_tasks = true
</span><span class="uncovered1"><a name="line2287"></a>2287             options.show_task_pattern = Regexp.new(value || '')
</span><span class="uncovered0"><a name="line2288"></a>2288             options.full_description = false
</span><span class="uncovered1"><a name="line2289"></a>2289           }
</span><span class="uncovered0"><a name="line2290"></a>2290         ],
</span><span class="uncovered1"><a name="line2291"></a>2291         ['--trace', '-t', &quot;Turn on invoke/execute tracing, enable full backtrace.&quot;,
</span><span class="uncovered0"><a name="line2292"></a>2292           lambda { |value|
</span><span class="uncovered1"><a name="line2293"></a>2293             options.trace = true
</span><span class="uncovered0"><a name="line2294"></a>2294             verbose(true)
</span><span class="uncovered1"><a name="line2295"></a>2295           }
</span><span class="uncovered0"><a name="line2296"></a>2296         ],
</span><span class="uncovered1"><a name="line2297"></a>2297         ['--verbose', '-v', &quot;Log message to standard output.&quot;,
</span><span class="uncovered0"><a name="line2298"></a>2298           lambda { |value| verbose(true) }
</span><span class="uncovered1"><a name="line2299"></a>2299         ],
</span><span class="uncovered0"><a name="line2300"></a>2300         ['--version', '-V', &quot;Display the program version.&quot;,
</span><span class="uncovered1"><a name="line2301"></a>2301           lambda { |value|
</span><span class="uncovered0"><a name="line2302"></a>2302             puts &quot;rake, version #{RAKEVERSION}&quot;
</span><span class="uncovered1"><a name="line2303"></a>2303             exit
</span><span class="uncovered0"><a name="line2304"></a>2304           }
</span><span class="uncovered1"><a name="line2305"></a>2305         ]
</span><span class="uncovered0"><a name="line2306"></a>2306       ]
</span><span class="uncovered1"><a name="line2307"></a>2307     end
</span><span class="inferred0"><a name="line2308"></a>2308 
</span><span class="inferred1"><a name="line2309"></a>2309     # Read and handle the command line options.
</span><span class="marked0"><a name="line2310"></a>2310     def handle_options
</span><span class="uncovered1"><a name="line2311"></a>2311       options.rakelib = ['rakelib']
</span><span class="uncovered0"><a name="line2312"></a>2312 
</span><span class="uncovered1"><a name="line2313"></a>2313       OptionParser.new do |opts|
</span><span class="uncovered0"><a name="line2314"></a>2314         opts.banner = &quot;rake [-f rakefile] {options} targets...&quot;
</span><span class="uncovered1"><a name="line2315"></a>2315         opts.separator &quot;&quot;
</span><span class="uncovered0"><a name="line2316"></a>2316         opts.separator &quot;Options are ...&quot;
</span><span class="uncovered1"><a name="line2317"></a>2317 
</span><span class="uncovered0"><a name="line2318"></a>2318         opts.on_tail(&quot;-h&quot;, &quot;--help&quot;, &quot;-H&quot;, &quot;Display this help message.&quot;) do
</span><span class="uncovered1"><a name="line2319"></a>2319           puts opts
</span><span class="uncovered0"><a name="line2320"></a>2320           exit
</span><span class="uncovered1"><a name="line2321"></a>2321         end
</span><span class="uncovered0"><a name="line2322"></a>2322 
</span><span class="uncovered1"><a name="line2323"></a>2323         standard_rake_options.each { |args| opts.on(*args) }
</span><span class="uncovered0"><a name="line2324"></a>2324       end.parse!
</span><span class="uncovered1"><a name="line2325"></a>2325 
</span><span class="uncovered0"><a name="line2326"></a>2326       # If class namespaces are requested, set the global options
</span><span class="uncovered1"><a name="line2327"></a>2327       # according to the values in the options structure.
</span><span class="uncovered0"><a name="line2328"></a>2328       if options.classic_namespace
</span><span class="uncovered1"><a name="line2329"></a>2329         $show_tasks = options.show_tasks
</span><span class="uncovered0"><a name="line2330"></a>2330         $show_prereqs = options.show_prereqs
</span><span class="uncovered1"><a name="line2331"></a>2331         $trace = options.trace
</span><span class="uncovered0"><a name="line2332"></a>2332         $dryrun = options.dryrun
</span><span class="uncovered1"><a name="line2333"></a>2333         $silent = options.silent
</span><span class="uncovered0"><a name="line2334"></a>2334       end
</span><span class="uncovered1"><a name="line2335"></a>2335     end
</span><span class="inferred0"><a name="line2336"></a>2336 
</span><span class="inferred1"><a name="line2337"></a>2337     # Similar to the regular Ruby +require+ command, but will check
</span><span class="inferred0"><a name="line2338"></a>2338     # for *.rake files in addition to *.rb files.
</span><span class="marked1"><a name="line2339"></a>2339     def rake_require(file_name, paths=$LOAD_PATH, loaded=$&quot;)
</span><span class="uncovered0"><a name="line2340"></a>2340       return false if loaded.include?(file_name)
</span><span class="uncovered1"><a name="line2341"></a>2341       paths.each do |path|
</span><span class="uncovered0"><a name="line2342"></a>2342         fn = file_name + &quot;.rake&quot;
</span><span class="uncovered1"><a name="line2343"></a>2343         full_path = File.join(path, fn)
</span><span class="uncovered0"><a name="line2344"></a>2344         if File.exist?(full_path)
</span><span class="uncovered1"><a name="line2345"></a>2345           load full_path
</span><span class="uncovered0"><a name="line2346"></a>2346           loaded &lt;&lt; fn
</span><span class="uncovered1"><a name="line2347"></a>2347           return true
</span><span class="uncovered0"><a name="line2348"></a>2348         end
</span><span class="uncovered1"><a name="line2349"></a>2349       end
</span><span class="uncovered0"><a name="line2350"></a>2350       fail LoadError, &quot;Can't find #{file_name}&quot;
</span><span class="uncovered1"><a name="line2351"></a>2351     end
</span><span class="inferred0"><a name="line2352"></a>2352 
</span><span class="marked1"><a name="line2353"></a>2353     def find_rakefile_location
</span><span class="uncovered0"><a name="line2354"></a>2354       here = Dir.pwd
</span><span class="uncovered1"><a name="line2355"></a>2355       while ! (fn = have_rakefile)
</span><span class="uncovered0"><a name="line2356"></a>2356         Dir.chdir(&quot;..&quot;)
</span><span class="uncovered1"><a name="line2357"></a>2357         if Dir.pwd == here || options.nosearch
</span><span class="uncovered0"><a name="line2358"></a>2358           return nil
</span><span class="uncovered1"><a name="line2359"></a>2359         end
</span><span class="uncovered0"><a name="line2360"></a>2360         here = Dir.pwd
</span><span class="uncovered1"><a name="line2361"></a>2361       end
</span><span class="uncovered0"><a name="line2362"></a>2362       [fn, here]
</span><span class="uncovered1"><a name="line2363"></a>2363     ensure
</span><span class="uncovered0"><a name="line2364"></a>2364       Dir.chdir(Rake.original_dir)
</span><span class="uncovered1"><a name="line2365"></a>2365     end
</span><span class="inferred0"><a name="line2366"></a>2366 
</span><span class="marked1"><a name="line2367"></a>2367     def raw_load_rakefile # :nodoc:
</span><span class="uncovered0"><a name="line2368"></a>2368       rakefile, location = find_rakefile_location
</span><span class="uncovered1"><a name="line2369"></a>2369       if (! options.ignore_system) &amp;&amp;
</span><span class="uncovered0"><a name="line2370"></a>2370           (options.load_system || rakefile.nil?) &amp;&amp;
</span><span class="uncovered1"><a name="line2371"></a>2371           system_dir &amp;&amp; File.directory?(system_dir)
</span><span class="uncovered0"><a name="line2372"></a>2372         puts &quot;(in #{Dir.pwd})&quot; unless options.silent
</span><span class="uncovered1"><a name="line2373"></a>2373         glob(&quot;#{system_dir}/*.rake&quot;) do |name|
</span><span class="uncovered0"><a name="line2374"></a>2374           add_import name
</span><span class="uncovered1"><a name="line2375"></a>2375         end
</span><span class="uncovered0"><a name="line2376"></a>2376       else
</span><span class="uncovered1"><a name="line2377"></a>2377         fail &quot;No Rakefile found (looking for: #{@rakefiles.join(', ')})&quot; if
</span><span class="uncovered0"><a name="line2378"></a>2378           rakefile.nil?
</span><span class="uncovered1"><a name="line2379"></a>2379         @rakefile = rakefile
</span><span class="uncovered0"><a name="line2380"></a>2380         Dir.chdir(location)
</span><span class="uncovered1"><a name="line2381"></a>2381         puts &quot;(in #{Dir.pwd})&quot; unless options.silent
</span><span class="uncovered0"><a name="line2382"></a>2382         $rakefile = @rakefile if options.classic_namespace
</span><span class="uncovered1"><a name="line2383"></a>2383         load File.expand_path(@rakefile) if @rakefile &amp;&amp; @rakefile != ''
</span><span class="uncovered0"><a name="line2384"></a>2384         options.rakelib.each do |rlib|
</span><span class="uncovered1"><a name="line2385"></a>2385           glob(&quot;#{rlib}/*.rake&quot;) do |name|
</span><span class="uncovered0"><a name="line2386"></a>2386             add_import name
</span><span class="uncovered1"><a name="line2387"></a>2387           end
</span><span class="uncovered0"><a name="line2388"></a>2388         end
</span><span class="uncovered1"><a name="line2389"></a>2389       end
</span><span class="uncovered0"><a name="line2390"></a>2390       load_imports
</span><span class="uncovered1"><a name="line2391"></a>2391     end
</span><span class="inferred0"><a name="line2392"></a>2392 
</span><span class="marked1"><a name="line2393"></a>2393     def glob(path, &amp;block)
</span><span class="uncovered0"><a name="line2394"></a>2394       Dir[path.gsub(&quot;\\&quot;, '/')].each(&amp;block)
</span><span class="uncovered1"><a name="line2395"></a>2395     end
</span><span class="marked0"><a name="line2396"></a>2396     private :glob
</span><span class="inferred1"><a name="line2397"></a>2397 
</span><span class="inferred0"><a name="line2398"></a>2398     # The directory path containing the system wide rakefiles.
</span><span class="marked1"><a name="line2399"></a>2399     def system_dir
</span><span class="uncovered0"><a name="line2400"></a>2400       @system_dir ||=
</span><span class="uncovered1"><a name="line2401"></a>2401         begin
</span><span class="uncovered0"><a name="line2402"></a>2402           if ENV['RAKE_SYSTEM']
</span><span class="uncovered1"><a name="line2403"></a>2403             ENV['RAKE_SYSTEM']
</span><span class="uncovered0"><a name="line2404"></a>2404           else
</span><span class="uncovered1"><a name="line2405"></a>2405             standard_system_dir
</span><span class="uncovered0"><a name="line2406"></a>2406           end
</span><span class="uncovered1"><a name="line2407"></a>2407         end
</span><span class="uncovered0"><a name="line2408"></a>2408     end
</span><span class="inferred1"><a name="line2409"></a>2409     
</span><span class="inferred0"><a name="line2410"></a>2410     # The standard directory containing system wide rake files.
</span><span class="marked1"><a name="line2411"></a>2411     if Win32.windows?
</span><span class="uncovered0"><a name="line2412"></a>2412       def standard_system_dir #:nodoc:
</span><span class="uncovered1"><a name="line2413"></a>2413         Win32.win32_system_dir
</span><span class="uncovered0"><a name="line2414"></a>2414       end
</span><span class="inferred1"><a name="line2415"></a>2415     else
</span><span class="marked0"><a name="line2416"></a>2416       def standard_system_dir #:nodoc:
</span><span class="uncovered1"><a name="line2417"></a>2417         File.join(File.expand_path('~'), '.rake')
</span><span class="uncovered0"><a name="line2418"></a>2418       end
</span><span class="uncovered1"><a name="line2419"></a>2419     end
</span><span class="marked0"><a name="line2420"></a>2420     private :standard_system_dir
</span><span class="inferred1"><a name="line2421"></a>2421 
</span><span class="inferred0"><a name="line2422"></a>2422     # Collect the list of tasks on the command line.  If no tasks are
</span><span class="inferred1"><a name="line2423"></a>2423     # given, return a list containing only the default task.
</span><span class="inferred0"><a name="line2424"></a>2424     # Environmental assignments are processed at this time as well.
</span><span class="marked1"><a name="line2425"></a>2425     def collect_tasks
</span><span class="uncovered0"><a name="line2426"></a>2426       @top_level_tasks = []
</span><span class="uncovered1"><a name="line2427"></a>2427       ARGV.each do |arg|
</span><span class="uncovered0"><a name="line2428"></a>2428         if arg =~ /^(\w+)=(.*)$/
</span><span class="uncovered1"><a name="line2429"></a>2429           ENV[$1] = $2
</span><span class="uncovered0"><a name="line2430"></a>2430         else
</span><span class="uncovered1"><a name="line2431"></a>2431           @top_level_tasks &lt;&lt; arg unless arg =~ /^-/
</span><span class="uncovered0"><a name="line2432"></a>2432         end
</span><span class="uncovered1"><a name="line2433"></a>2433       end
</span><span class="uncovered0"><a name="line2434"></a>2434       @top_level_tasks.push(&quot;default&quot;) if @top_level_tasks.size == 0
</span><span class="uncovered1"><a name="line2435"></a>2435     end
</span><span class="inferred0"><a name="line2436"></a>2436 
</span><span class="inferred1"><a name="line2437"></a>2437     # Add a file to the list of files to be imported.
</span><span class="marked0"><a name="line2438"></a>2438     def add_import(fn)
</span><span class="uncovered1"><a name="line2439"></a>2439       @pending_imports &lt;&lt; fn
</span><span class="uncovered0"><a name="line2440"></a>2440     end
</span><span class="inferred1"><a name="line2441"></a>2441 
</span><span class="inferred0"><a name="line2442"></a>2442     # Load the pending list of imported files.
</span><span class="marked1"><a name="line2443"></a>2443     def load_imports
</span><span class="uncovered0"><a name="line2444"></a>2444       while fn = @pending_imports.shift
</span><span class="uncovered1"><a name="line2445"></a>2445         next if @imported.member?(fn)
</span><span class="uncovered0"><a name="line2446"></a>2446         if fn_task = lookup(fn)
</span><span class="uncovered1"><a name="line2447"></a>2447           fn_task.invoke
</span><span class="uncovered0"><a name="line2448"></a>2448         end
</span><span class="uncovered1"><a name="line2449"></a>2449         ext = File.extname(fn)
</span><span class="uncovered0"><a name="line2450"></a>2450         loader = @loaders[ext] || @default_loader
</span><span class="uncovered1"><a name="line2451"></a>2451         loader.load(fn)
</span><span class="uncovered0"><a name="line2452"></a>2452         @imported &lt;&lt; fn
</span><span class="uncovered1"><a name="line2453"></a>2453       end
</span><span class="uncovered0"><a name="line2454"></a>2454     end
</span><span class="inferred1"><a name="line2455"></a>2455 
</span><span class="inferred0"><a name="line2456"></a>2456     # Warn about deprecated use of top level constant names.
</span><span class="marked1"><a name="line2457"></a>2457     def const_warning(const_name)
</span><span class="uncovered0"><a name="line2458"></a>2458       @const_warning ||= false
</span><span class="uncovered1"><a name="line2459"></a>2459       if ! @const_warning
</span><span class="uncovered0"><a name="line2460"></a>2460         $stderr.puts %{WARNING: Deprecated reference to top-level constant '#{const_name}' } +
</span><span class="uncovered1"><a name="line2461"></a>2461           %{found at: #{rakefile_location}} # '
</span><span class="uncovered0"><a name="line2462"></a>2462         $stderr.puts %{    Use --classic-namespace on rake command}
</span><span class="uncovered1"><a name="line2463"></a>2463         $stderr.puts %{    or 'require &quot;rake/classic_namespace&quot;' in Rakefile}
</span><span class="uncovered0"><a name="line2464"></a>2464       end
</span><span class="uncovered1"><a name="line2465"></a>2465       @const_warning = true
</span><span class="uncovered0"><a name="line2466"></a>2466     end
</span><span class="inferred1"><a name="line2467"></a>2467 
</span><span class="marked0"><a name="line2468"></a>2468     def rakefile_location
</span><span class="uncovered1"><a name="line2469"></a>2469       begin
</span><span class="uncovered0"><a name="line2470"></a>2470         fail
</span><span class="uncovered1"><a name="line2471"></a>2471       rescue RuntimeError =&gt; ex
</span><span class="uncovered0"><a name="line2472"></a>2472         ex.backtrace.find {|str| str =~ /#{@rakefile}/ } || &quot;&quot;
</span><span class="uncovered1"><a name="line2473"></a>2473       end
</span><span class="uncovered0"><a name="line2474"></a>2474     end
</span><span class="uncovered1"><a name="line2475"></a>2475   end
</span><span class="uncovered0"><a name="line2476"></a>2476 end
</span><span class="inferred1"><a name="line2477"></a>2477 
</span><span class="inferred0"><a name="line2478"></a>2478 
</span><span class="marked1"><a name="line2479"></a>2479 class Module
</span><span class="inferred0"><a name="line2480"></a>2480   # Rename the original handler to make it available.
</span><span class="marked1"><a name="line2481"></a>2481   alias :rake_original_const_missing :const_missing
</span><span class="inferred0"><a name="line2482"></a>2482 
</span><span class="inferred1"><a name="line2483"></a>2483   # Check for deprecated uses of top level (i.e. in Object) uses of
</span><span class="inferred0"><a name="line2484"></a>2484   # Rake class names.  If someone tries to reference the constant
</span><span class="inferred1"><a name="line2485"></a>2485   # name, display a warning and return the proper object.  Using the
</span><span class="inferred0"><a name="line2486"></a>2486   # --classic-namespace command line option will define these
</span><span class="inferred1"><a name="line2487"></a>2487   # constants in Object and avoid this handler.
</span><span class="marked0"><a name="line2488"></a>2488   def const_missing(const_name)
</span><span class="uncovered1"><a name="line2489"></a>2489     case const_name
</span><span class="uncovered0"><a name="line2490"></a>2490     when :Task
</span><span class="uncovered1"><a name="line2491"></a>2491       Rake.application.const_warning(const_name)
</span><span class="uncovered0"><a name="line2492"></a>2492       Rake::Task
</span><span class="uncovered1"><a name="line2493"></a>2493     when :FileTask
</span><span class="uncovered0"><a name="line2494"></a>2494       Rake.application.const_warning(const_name)
</span><span class="uncovered1"><a name="line2495"></a>2495       Rake::FileTask
</span><span class="uncovered0"><a name="line2496"></a>2496     when :FileCreationTask
</span><span class="uncovered1"><a name="line2497"></a>2497       Rake.application.const_warning(const_name)
</span><span class="uncovered0"><a name="line2498"></a>2498       Rake::FileCreationTask
</span><span class="uncovered1"><a name="line2499"></a>2499     when :RakeApp
</span><span class="uncovered0"><a name="line2500"></a>2500       Rake.application.const_warning(const_name)
</span><span class="uncovered1"><a name="line2501"></a>2501       Rake::Application
</span><span class="uncovered0"><a name="line2502"></a>2502     else
</span><span class="uncovered1"><a name="line2503"></a>2503       rake_original_const_missing(const_name)
</span><span class="uncovered0"><a name="line2504"></a>2504     end
</span><span class="uncovered1"><a name="line2505"></a>2505   end
</span><span class="uncovered0"><a name="line2506"></a>2506 end
</span></pre><hr/>
    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a>
   version 0.8.1.2.</p>
<p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88'/>
        </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px'/>
        </a>
      </p>
    </body>
  </html>
